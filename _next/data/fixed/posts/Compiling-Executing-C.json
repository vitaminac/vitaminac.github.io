{
  "pageProps": {
    "postData": {
      "title": "The Process Behind Compiling and Executing C Code",
      "markdownContentSource": "\n## Introduction\n\nCompiling and executing a C program is a multi-stage process. In this post Iâ€™ll walk through each stages of compiling and executing the following C program with filename `test.c`:\n\n    #include <stdio.h>\n\n    #define LOOP_TIMES 10\n\n    int main(int argc, char *argv[])\n    {\n        for (int i = 0; i < LOOP_TIMES; i++)\n        {\n            printf(\"Hello World #%i!\\n\", i);\n        }\n        return 0;\n    }\n\nOur testings are performs on Debian Bullseye AMD64, intermediate result may vary depending on the OS and hardware.\n\n## Preprocessing\n\nThe first stage of compilation is called preprocessing. In this stage, the C pre-processor is responsible for handling pre-processor directives (lines starting with a `#` character). These pre-processor directives form a simple macro language with its own syntax and semantics. This language is used to reduce repetition in source code, e.g. lines with `#include` are replaced by the contents of the referenced file (with different search rules for names in quotes versus those in angle brackets). Names introduced with `#define` are systematically replaced with their definitions throughout the program, `#if` and its relatives are processed to conditionally omit code, etc...\n\nTo get the result of the preprocessing stage, we can pass `-E` option to `gcc`\n\n    gcc -E -o test.i test.c\n\nThe output after preprocessing stage in my machine look like following\n\n    // ... omitted for brevity\n    # 873 \"/usr/include/stdio.h\" 3 4\n\n    # 2 \"test.c\" 2\n\n\n\n\n    # 5 \"test.c\"\n    int main(int argc, char *argv[])\n    {\n        for (int i = 0; i < 10; i++)\n        {\n            printf(\"Hello World #%i!\\n\", i);\n        }\n        return 0;\n    }\n\n## Compilation\n\nIn this stage, the actual compiler translates pre-processed source into assembly language. These form an intermediate human-readable language. The existence of this step allows for C code to contain inline assembly instructions and for different assemblers to be used. To get the result of the compilation stage, pass the `-S` option to `gcc`:\n\n    gcc -S -o test.s test.i\n\nThe output after compilation stage in my machine look like following\n\n        .file\t\"test.c\"\n        .text\n        .section\t.rodata\n    .LC0:\n        .string\t\"Hello World #%i!\\n\"\n        .text\n        .globl\tmain\n        .type\tmain, @function\n    main:\n    .LFB0:\n        .cfi_startproc\n        pushq\t%rbp\n        .cfi_def_cfa_offset 16\n        .cfi_offset 6, -16\n        movq\t%rsp, %rbp\n        .cfi_def_cfa_register 6\n        subq\t$32, %rsp\n        movl\t%edi, -20(%rbp)\n        movq\t%rsi, -32(%rbp)\n        movl\t$0, -4(%rbp)\n        jmp\t.L2\n    .L3:\n        movl\t-4(%rbp), %eax\n        movl\t%eax, %esi\n        leaq\t.LC0(%rip), %rdi\n        movl\t$0, %eax\n        call\tprintf@PLT\n        addl\t$1, -4(%rbp)\n    .L2:\n        cmpl\t$9, -4(%rbp)\n        jle\t.L3\n        movl\t$0, %eax\n        leave\n        .cfi_def_cfa 7, 8\n        ret\n        .cfi_endproc\n    .LFE0:\n        .size\tmain, .-main\n        .ident\t\"GCC: (Debian 10.2.1-6) 10.2.1 20210110\"\n        .section\t.note.GNU-stack,\"\",@progbits\n\n## Assembly\n\nDuring this stage, The assembler converts the assembly language source to an unlinked relocatable object file in ELF format. The output contains the actual instructions to be run by the target processor. However, an unlinked relocatable object file is not executable yet: it may require definitions from other files, including libraries. To get the result of the assembly stage, pass the `-c` option to `gcc`:\n\n    gcc -c -o test.o test.s\n\nor we can manually invoke `as`\n\n    as -o test.o test.s\n\nRunning the above command will produce an unlinked relocatable object file in ELF format named `test.o`. We can inspect the ELF sections with `readelf -a test.o | less` and to see the content of specific section we can use `readelf -x .text test.o`.\n\n## Linking\n\nThe object files generated in the assembly stage is composed of machine instructions that the processor understands, but some pieces of the program are out of order or missing. The linker resolves all the references in a set of object files or archive so that functions in some pieces can successfully call functions in other ones, and then produces an executable. To get the final executable use following command, `-v` option give us detail information of linking process.\n\n    gcc -v -o test.elf test.o\n\nWe can also manually invoke linker separately using `ld` to get the final executable.\n\n    GLIBC_LIB_DIR=\"/usr/lib/x86_64-linux-gnu\"\n    GCC_LIB_DIR=\"/usr/lib/gcc/x86_64-linux-gnu/10\"\n    STARTFILES=\"$GLIBC_LIB_DIR/crt1.o $GLIBC_LIB_DIR/crti.o\"\n    ENDFILES=\"$GLIBC_LIB_DIR/crtn.o\"\n    ld -o test.elf -dynamic-linker /lib64/ld-linux-x86-64.so.2 $STARTFILES test.o $GLIBC_LIB_DIR/libc.so $ENDFILES\n\nThe final executable is also a ELF file.\n\n## ELF\n\nExecutable and Linkable Format (ELF) is a common standard file format used in UNIX system for executable files, object code, shared libraries, and core dumps.\n\n## Execution\n\nAt first, it seems when a program is executed, it starts with the [`int main(int argc, char *argv[])`](https://en.cppreference.com/w/c/language/main_function), however it is not quite true.\n\n### Load Executable with Interpreter\n\nFirstly, when we try to run a program, it trigger an [`execve` system call](https://elixir.bootlin.com/linux/v5.15.6/source/fs/exec.c#L2063) to the kernel. The kernel [allocates the structure `linux_binprm` for a new process](https://elixir.bootlin.com/linux/v5.15.6/source/fs/exec.c#L1891), [open the executable file from disk](https://elixir.bootlin.com/linux/v5.15.6/source/fs/exec.c#L1810), [find the corresponding interpreter for the executable](https://elixir.bootlin.com/linux/v5.15.6/source/fs/exec.c#L1766), in case of our C program executable in ELF format is then [executed](https://elixir.bootlin.com/linux/v5.15.6/source/fs/exec.c#L1725) with [ELF loader](https://elixir.bootlin.com/linux/v5.15.6/source/fs/binfmt_elf.c#L823).\n\n### Load Dynamic Linker\n\nThe ELF loader [read program headers table of executable which contains a field `INTERP`](https://elixir.bootlin.com/linux/v5.15.6/source/fs/binfmt_elf.c#L873). For dynamically linked program `INTERP` is the path to dynamic linker. We can use `readelf --program-headers test.elf` to see the program headers table and use `readelf -x .interp test.elf` to see the value of `INTERP`, its value is `/lib64/ld-linux-x86-64.so.2` in my machine. The kernel [opens](https://elixir.bootlin.com/linux/v5.15.6/source/fs/binfmt_elf.c#L898) and [reads the dynamic linker executable in ELF format](https://elixir.bootlin.com/linux/v5.15.6/source/fs/binfmt_elf.c#L917).\n\n### Auxiliary Vector\n\nKernel uses a special structure called the [auxiliary vector or auxv](https://elixir.bootlin.com/linux/v5.15.6/source/include/linux/mm_types.h#L506) to comminicate with dymanic linker. Kernel [prepares `auxv`](https://elixir.bootlin.com/linux/v5.15.6/source/fs/binfmt_elf.c#L1257) and pass `auxv` by putting on the stack for the newly created program. Thus, when the dynamic linker starts it can use its stack pointer to find the all the startup information required. It contains system specific information that may be required, such as the default size of a virtual memory page on the system or hardware capabilities. We can request the dynamic linker to show some debugging output of the auxv by specifying the environment value `LD_SHOW_AUXV=1`\n\n### Call Dynamic Linker with Program Entry Point\n\nKernel [looks for the `e_entry` field](https://elixir.bootlin.com/linux/v5.15.6/source/fs/binfmt_elf.c#L1193) from the `ELF` header of our program executable which contains the entry point address which by default is symbol `_start`. We can examine the entry point with `objdump -f test.elf`.  We can use option `--entry=<symbol name>` of `ld` to change entry point to other symbol.\n\nKernel [adds the value of `e_entry` to auxv](https://elixir.bootlin.com/linux/v5.15.6/source/fs/binfmt_elf.c#L267). Kernel then [starts the execution](https://elixir.bootlin.com/linux/v5.15.6/source/fs/binfmt_elf.c#L1313) from the [entry point address as specified by dynamic linker](https://elixir.bootlin.com/linux/v5.15.6/source/fs/binfmt_elf.c#L1215).\n\n### Dynamic Linker\n\nInvestigating the dynamic linker with command `objdump -f /lib64/ld-linux-x86-64.so.2` and `objdump --disassemble --section=.text /lib64/ld-linux-x86-64.so.2` we found the entry point of dynamic linker is [function `_dl_rtld_di_serinfo`](https://elixir.bootlin.com/glibc/glibc-2.31/source/elf/dl-load.c#L2263). It does some linking process on the fly by loading any libraries as specified in the dynamic section of the program executable in ELF format and then continue execution from our program executable entry point address which was passed in.\n\n### Kernel Library\n\nTo avoid the overheads of system calls by triggering a trap to the processor which is slow. Kernel loads a shared library (ref: [#1](https://elixir.bootlin.com/linux/v5.15.6/source/fs/binfmt_elf.c#L1252), [#2](https://elixir.bootlin.com/linux/v5.15.6/source/include/linux/elf.h#L31), [#3](https://elixir.bootlin.com/linux/v5.15.6/source/arch/x86/entry/vdso/vma.c#L394)) into the address space of every newly created process which contains a function that makes system calls for you. When the kernel starts the dynamic linker it adds an entry `AT_SYSINFO_EHDR` to the `auxv` structure (ref: [#1](https://elixir.bootlin.com/linux/v5.15.6/source/fs/binfmt_elf.c#L255), [#2](https://elixir.bootlin.com/linux/v5.15.6/source/arch/x86/include/asm/elf.h#L352)) which is the address in the memory that the special kernel library lives in. When the dynamic linker starts it can look for the `AT_SYSINFO_EHDR` pointer, and if found load that library for the program. The program has no idea this library exists; this is a private arrangement between the dynamic linker and the kernel.\n\nThe programmers make system calls indirectly through calling functions in the standard C library. The standard C library can check to see if the special kernel binary is loaded, and if so use the functions within that to make system calls. If the kernel determines the hardware is capable, this will use the fast system call method.\n\n### The role of `_start` function\n\nAs you might have already noticed, in the linking section we have to include somes extras files, this is because [the symbol `_start`](https://elixir.bootlin.com/glibc/glibc-2.31/source/sysdeps/x86_64/start.S#L58) is defined in `crt1.o` (Some systems use [crt0.o](https://en.wikipedia.org/wiki/Crt0), while some use `crt1.o` and a few even use `crt2.o` or higher). It takes care of bootstrapping the initial execution of the program, e.g. setup arguments, prepare environment variables for program execution etc. What exactly that entails is highly [`libc` implementation](https://en.wikipedia.org/wiki/C_standard_library#Implementations) dependent. The objects are provided by [different implementations of libc](http://www.etalabs.net/compare_libcs.html) and cannot be mixed with other ones.\n\nThe following code is disassembled version of `_start` with `objdump --disassemble=_start test.elf`:\n\n    0000000000401040 <_start>:\n              401040:\t      31 ed                \txor    %ebp,%ebp\n              401042:\t      49 89 d1             \tmov    %rdx,%r9\n              401045:\t      5e                   \tpop    %rsi\n              401046:\t      48 89 e2             \tmov    %rsp,%rdx\n              401049:\t      48 83 e4 f0          \tand    $0xfffffffffffffff0,%rsp\n              40104d:\t      50                   \tpush   %rax\n              40104e:\t      54                   \tpush   %rsp\n              40104f:\t      49 c7 c0 10 11 40 00 \tmov    $0x401110,%r8        # __libc_csu_fini\n              401056:\t      48 c7 c1 b0 10 40 00 \tmov    $0x4010b0,%rcx       # __libc_csu_init\n              40105d:\t      48 c7 c7 71 10 40 00 \tmov    $0x401071,%rdi       # our main function\n              401064:\t      ff 15 86 2f 00 00    \tcallq  *0x2f86(%rip)        # 403ff0 <__libc_start_main@GLIBC_2.2.5>\n              40106a:\t      f4                   \thlt    \n\nOn glibc 2.31, `_start` [initializes very early ABI requirements](https://elixir.bootlin.com/glibc/glibc-2.31/source/sysdeps/x86_64/start.S#L59) (like the stack or frame pointer), [setting up the `argc`/`argv`/`env` values](https://elixir.bootlin.com/glibc/glibc-2.31/source/sysdeps/x86_64/start.S#L85), and then [pass pointers](https://elixir.bootlin.com/glibc/glibc-2.31/source/sysdeps/x86_64/start.S#L107) of [__libc_csu_init](https://elixir.bootlin.com/glibc/glibc-2.31/source/csu/elf-init.c#L67), [__libc_csu_fini](https://elixir.bootlin.com/glibc/glibc-2.31/source/csu/elf-init.c#L95) and main function to [`__libc_start_main`](https://refspecs.linuxbase.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html) which in turn does more general bootstrapping before finally calling the real main function.\n\nThe [implementation of `__libc_start_main`](https://elixir.bootlin.com/glibc/glibc-2.2.5/source/sysdeps/generic/libc-start.c#L49) is quite complicated as it needs to be portable across the very wide number of systems and architectures that `glibc` can run on. It does a number of specific things related to setting up the C library which the most of the programmers don't need to worry about. \n\n### Initialization and Termination Routines\n\n`init` and `fini` are two special parts of code in shared libraries that may need to be called before the library starts, and before the library is unloaded respectively. This might be useful for library programmers to setup variables when the library is started, or to clean up at the end. `__libc_start_main` [call the `__libc_csu_init`](https://elixir.bootlin.com/glibc/glibc-2.2.5/source/sysdeps/generic/libc-start.c#L122) before calling our main function and [register `__libc_csu_fini` as a callback to be called before program exit](https://elixir.bootlin.com/glibc/glibc-2.2.5/source/sysdeps/generic/libc-start.c#L114) with [__cxa_atexit](https://refspecs.linuxbase.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/baselib---cxa-atexit.html). What `__libc_csu_init`/`__libc_csu_fini` do is simply loop the list of [init](https://elixir.bootlin.com/glibc/glibc-2.31/source/csu/elf-init.c#L88)/[fini](https://elixir.bootlin.com/glibc/glibc-2.31/source/csu/elf-init.c#L100) function and invokes them.\n\nIn order to traverse the list of `init` functions, two symbols `__init_array_start` and `__init_array_end` is defined during the linking process and exported as part of ELF symbol table `.symtab`.\n\nWe can use `__attribute__((constructor))` and `__attribute__((destructor))` (ref: [#1](https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes)) to add [initialization and termination routines](https://gcc.gnu.org/onlinedocs/gccint/Initialization.html) to our program, e.g.\n\n    void __attribute__((constructor)) program_init(void)\n    {\n        printf(\"init\\n\");\n    }\n\n    void __attribute__((destructor)) program_fini(void)\n    {\n        printf(\"fini\\n\");\n    }\n\nIn the new realease of `glibc` the process of `fini` was changed as part of this [commit](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=9dcafc559763e339d4a79580c333127033e39c11).\n\n### Call Main Function\n\nOnce `__libc_start_main` has completed with the initialization it finally [calls the main function](https://elixir.bootlin.com/glibc/glibc-2.2.5/source/sysdeps/generic/libc-start.c#L129)! Remember that it had the stack setup initially with the arguments and environment pointers from the kernel; this is how main gets its `argc`, `argv[]`, [envp[]](https://stackoverflow.com/a/10321474/9980245) arguments.\n\n### Exit\n\nWhen the main function returns `__libc_start_main` call [`void exit(int exit_code)`](https://en.cppreference.com/w/c/program/exit) with return value of main function as exit code. The [implementation of `exit`](https://elixir.bootlin.com/glibc/glibc-2.31/source/stdlib/exit.c#L137) is trigger a syscall exit_group (ref: [#1](https://elixir.bootlin.com/glibc/glibc-2.31/source/sysdeps/unix/sysv/linux/_exit.c#L31), [#2](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/sysdep.h;h=3ef72dc805a6e6246f8fafd935108ff3c10591b1;hb=HEAD#l42), [#3](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/i386/sysdep.h;h=ec12c84ca877b87f0eaa7711900465e74d546565;hb=HEAD#l370), [#4](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/i386/sysdep.h;h=ec12c84ca877b87f0eaa7711900465e74d546565;hb=HEAD#l308), [#5](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/i386/sysdep.h;h=ec12c84ca877b87f0eaa7711900465e74d546565;hb=HEAD#l384), [#6](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/i386/arch-syscall.h;h=2512508b7daa8ed23d52cb5441e8ae36b5ef52da;hb=HEAD#l58)) to immediately stops the current process.\n\n## Writing program without `startfiles`\n\nNow we know how the call to the `main` is made. We can override the `_start` function to make it call our `main()`.\n\n    #include <stdio.h>\n    #include <stdlib.h>\n\n    #define LOOP_TIMES 10\n\n    void _start()\n    {\n        exit(main());\n    }\n\n    int main(void)\n    {\n        for (int i = 0; i < LOOP_TIMES; i++)\n        {\n            printf(\"Hello World #%i!\\n\", i);\n        }\n        return 0;\n    }\n\nNow we have to force `gcc` to use our implementation of `_start()`.\n\n    gcc -nostartfiles -o test.elf test.c\n\nWe can also manually invoke `ld`:\n\n    gcc -c -o test.o test.c\n    GLIBC_LIB_DIR=\"/usr/lib/x86_64-linux-gnu\"\n    GCC_LIB_DIR=\"/usr/lib/gcc/x86_64-linux-gnu/10\"\n    ld -o test.elf -dynamic-linker /lib64/ld-linux-x86-64.so.2 test.o $GLIBC_LIB_DIR/libc.so\n\n## Reference\n\n* [The Four Stages of Compiling a C Program](https://www.calleluks.com/the-four-stages-of-compiling-a-c-program/)\n* [Computer Science from the Bottom Up - Chapter 8. Behind the process - Starting a process](https://www.bottomupcs.com/starting_a_process.xhtml)\n* [What happens when you compile?](https://www.cs.tufts.edu/comp/40/docs/compiling-notes.html)\n* [GAS: Explanation of .cfi_def_cfa_offset](https://stackoverflow.com/a/7535848/9980245)\n* [segfault when linking with ld](https://www.linuxquestions.org/questions/programming-9/segfault-when-linking-with-ld-758599/)\n* [How to build a C program using a custom version of glibc and static linking?](https://coderedirect.com/questions/161733/how-to-build-a-c-program-using-a-custom-version-of-glibc-and-static-linking)\n* [Linking a C program directly with ld fails with undefined reference to `__libc_csu_fini`](https://stackoverflow.com/a/6658194/9980245)\n* [Linking a dynamically linked executable with ld](https://stackoverflow.com/a/6656952/9980245)\n* [What is the difference between crtbegin.o, crtbeginT.o and crtbeginS.o?](https://stackoverflow.com/a/27786892/9980245)\n* [ld(1) - Linux man page](https://linux.die.net/man/1/ld)\n* [readelf(1) â€” Linux manual page](https://man7.org/linux/man-pages/man1/readelf.1.html)\n* [GCC - Options for Linking: -nostartfiles](https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#index-nostartfiles)\n* [GCC Options for Code Generation Conventions](https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html)\n* [gcc(1) â€” Linux manual page](https://man7.org/linux/man-pages/man1/gcc.1.html)\n* [When is the gcc flag -nostartfiles used?](https://stackoverflow.com/a/62167438/9980245)\n* [How do I tell GCC not to link with the runtime library and the standard library?](https://stackoverflow.com/a/34237063/9980245)\n* [Executing main() in C/C++ â€“ behind the scene](https://www.geeksforgeeks.org/executing-main-in-c-behind-the-scene/)\n* [objdump(1) - Linux man page](https://linux.die.net/man/1/objdump)\n* [Objcopy elf to bin file](https://stackoverflow.com/a/49685103/9980245)\n* [objcopy(1) - Linux man page](https://linux.die.net/man/1/objcopy)\n* [BFD](https://sourceware.org/binutils/docs/ld/BFD.html)\n* [Wikipedia: Executable and Linkable Format](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)\n* [elf(5) â€” Linux manual page](https://man7.org/linux/man-pages/man5/elf.5.html)\n* [elf.h](https://elixir.bootlin.com/linux/v5.15.3/source/tools/objtool/include/objtool/elf.h#L79)\n* [How can I examine contents of a data section of an ELF file on Linux?](https://stackoverflow.com/a/30452453/9980245)\n* [exec(3) - Linux man page](https://linux.die.net/man/3/exec)\n* [execve(2) â€” Linux manual page](https://man7.org/linux/man-pages/man2/execve.2.html)\n* [Executing a flat binary file under Linux](https://stackoverflow.com/questions/1283342/executing-a-flat-binary-file-under-linux)\n* [load_flat_binary](https://elixir.bootlin.com/linux/v5.15.6/source/fs/binfmt_flat.c#L104)\n* [What is the difference between exit and return?](https://stackoverflow.com/a/3463562/9980245)\n* [What is the use of _start() in C?](https://stackoverflow.com/a/29694977/9980245)\n* [Syscall implementation of exit()](https://stackoverflow.com/a/46903734/9980245)",
      "slug": "Compiling-Executing-C",
      "date": "2021-12-18 22:28:10",
      "lang": "en",
      "tags": ["C", "Compilation", "ELF", "crt0", "exit"],
      "path": "/Compiling-Executing-C/index.html"
    },
    "lang": "en",
    "_nextI18Next": {
      "initialI18nStore": {
        "en": {
          "common": { "Next": "Next" },
          "feature-tags": { "Tags": "Tags" },
          "navbar": {
            "Home": "Home",
            "Language": "Language",
            "Tags": "Tags",
            "en": "English",
            "es": "Spanish",
            "zh": "Chinese"
          },
          "post-layout": { "Author": "Author: {{author}}" }
        }
      },
      "initialLocale": "en",
      "ns": ["common", "feature-tags", "navbar", "post-layout"],
      "userConfig": {
        "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] },
        "default": {
          "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] }
        }
      }
    }
  },
  "__N_SSG": true
}
