{
  "pageProps": {
    "postData": {
      "title": "Programación Lineal y Entera",
      "markdownContentSource": "\n# Programación Lineal\n\n## Introducción\n\nLa programación lineal es una herramienta matemática que nos proporciona una forma modelar el sistema y selelcionar el valor de las variables controlables que permiten un funcionamiento óptimo del sistema.\n\n## Construcción de modelos\n\n* Definir unas variables, de estado, de control, de salida.\n\n* Variables no controlables se modelan como variables aleatorias\n\n* Determinar los parámetros\n\n* Estudiar las relaciones entre los distintos elementos y representarlos mediante expresiones matemáticas.\n\n## Programación lineal\n\nLa Programación Lineal estudia la optimización de una función lineal en presencia de restricciones lineales.\n\nEn un problema general podemos encontrar\n\n* $m$ recursos\n\n* $n$ actividad\n\n* nivel de actividad\n\n* rendiemiento global $Z$\n\nDenotamos varios componentes de un modelo de programación con los siguientes siguientes simbolos\n\n* $Z$ = valor de la medida global del rendimiento, Normalmente puede interpretarse como el coste o el beneficio.\n\n* $x_j$ = nivel de actividad $j$ para $j = 1,2,...,n$\n\n* $c_j$ = el impacto en la funcion objetivo por unidad de actividad j.\n\n* $b_i$ = cantidad de recurso que está disponible para la asignación a actividades.\n\n* $a_{ij}$ = cantidad de recursos $i$ consumido por cada unidad de actividad $j$\n\n* $x_1, x_2, x_3, x_4$ son llamadas las variables de decisión, cada variable de decision de un PL (x1, . . . , xn) normalmente puede interpretarse como la eleccion del nivel de una actividad.\n\n![Problema](problema.png)\n\nLos $c_j$, $b_i$, $a_{ij}$ también se refieren como los párametros, algunos de ellos podrían ser estimaciones del valor exacto.\n\n## Forma estándar del modelo\n\n$$\n\\begin{split}\n\\max Z &= \\sum_j{c_jx_j}\\\\\nSujeto \\, a \\quad\n\\sum_{i}{a_{ij}}x_i &< b_i \\forall{j}\\\\\n\\end{split}\n$$\n\n## Tipos de puntos en un PL\n\nun **punto factible** es una solución que cumple todas las restricciones.\n\nun **punto no factible** es una solucón que se viola al menos una restricción.\n\nun **punto de frontera** es una solución que al menos una de desigualdad se cumple la igualdad.\n\nun **punto interior** Punto factible que no es punto frontera.\n\nun **punto estremo** or **CPF corner-point feasible** es la solución que se encuentra en la intersección de dos o mas línea, son los vértices del conjunto factible.\n\nUna **solución óptima** es punto factible con el mejor valor de la función objetivo.\n\nLa **región factible** es la colección de todas los puntos factibles.\n\n### Observación\n\nUn PL puede tener 0, 1, ó infinitos puntos óptimos. El mejor punto extremo debe ser una solución óptima.\n\n[Ejemplo](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/pl-ejemplo1.gms)\n\n## Modelos de asignación de recursos\n\nRepartimos un recursos entre varias actividades.\n\n### Variables de decisión\n\nDeterminan qué *cantidad de recursos* asignamos a cada actividad.\n\n### Restricciónes de repartos\n\nSon restricciones de igualdad.\n\n$$\n\\begin{split}\n\\min z(x) &= \\sum_i {c_i x_i}\\\\\ns.a. A\\textbf{x}&=\\textbf{b}\\\\\nx &\\ge 0\\\\\n\\end{split}\n$$\n\n[Modelo de Asignación - Cerveza](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/cerveza.gms)\n\n[Modelo de Asignación - Petroquimica](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/petroquimica.gms)\n\n[Modelo de Asignación - Minera](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/minera.gms)\n\n[Modelo de Asignación - cabre](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/cabre.gms)\n\n[Modelo de Asignación - Refinería](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/refineria.gms)\n\n[Modelo de Asignación - Leche](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/leche.gms)\n\n## Modelos de mezclas\n\nLos combinamos los recursos\n\n### Variables de mezclas\n\nDeterminan qué cantidad de cada recurso incluimos en la mezcla.\n\n### Restricciones de composición\n\nDeterminan cotas superiores y/o inferiores a las propiedades de la mezcla resultante.\n\n[Modelo de mezclas - Refinado](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/refinado.gms)\n\n[Modelo de mezclas - Siderúrgica](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/siderurgica.gms)\n\n[Modelo de mezclas - Dieta](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/dieta.gms)\n\n[Modelo de mezclas - Gasolina](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/gasolina.gms)\n\n## Modelos de planificación de operaciones\n\nDebemos decidir qué hacer, cuando, y donde.\n\n### Variables de decisión de gran magnitud\n\nLas variables de decisión enteras y de gran magnitud se suelen tratar como variables continuas para simplificar la solución del problemas.\n\n### Restricciones de balance\n\nEl flujo entrante de materias primas debe ser igual al flujo saliente de productos manufacturados (ecuación de balance).\n\n[Modelos de planificación de operaciones - Producción](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/produccion.gms)\n\n[Modelo de planificación de operaciones - Transporte](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/transporte.gms)\n\n[Modelo de planificación de operaciones - Transbordo](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/transbordo.gms)\n\n[Modelo de planificación de operaciones - Sumistradora](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/sumistradora.gms)\n\n[Modelo de planificación de operaciones - Residuos](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/residuos.gms)\n\n[Modelo de planificación de operaciones - Accion](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/accion.gms)\n\n[Modelo de planificación de operaciones - Agricultora](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/agricultora.gms)\n\n## Modelos de gestión de personal\n\nLos modelos de gestión de operaciones deciden qué tarea realizar en cada momento de forma que los recursos sean usados eficientemente, decidimos qué tipo de empleado y cuántos de cada tipo deben realizar cada tarea.\n\n### Restricciones de cubrimiento\n\nEn la planificación de los turnos debemos asegurar que el número de operario asignados cubre las necesidades de cada periodo. Para ello imponemos la siguiente restricción de cubrimiento.\n\n$$\n\\sum_{turnos} (Producción \\, por \\, operario) * (Operarios \\, en \\, servicio) \\ge  \\, del \\, periodo\n$$\n\n[Modelo de gestión de personal - Jornada](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/jornada.gms)\n\n## Modelos de planificación multiperiodo\n\nPlanificar en un horizonte de tiempo que abarca varios periodos, medelos dinámicos.\n\n### Variables de decisión por periodo\n\nMuchas variables de decisión tiene una versión para cada periodo\n\n### Restricciones de balace\n\nDescriben la evolucion temporal de una magnitud\n\n$$\nSituación_{t} + Cambios_{t} = Situación_{t + 1}\n$$\n\n[Modelos de planificación multiperiodo - Piensos](https://github.com/vitaminac/OperationsResearch/blob/master/Linear%20Programming/piensos.gms)\n\n## Resolución geométrica de un PL\n\nConsideramos un PL de dimesión dos, cuya función objectivo es\n\n$$\nz(x) = c^{T}x\n$$\n\ndonde $c^{T} = (c_1, c_2)$ y $x = (x_1, x_2) $.\n\nPara todos los puntos sobre la recta\n\n$$\nR_k = c^{T}x = k\n$$\n\nEl valor de la función objetivo es $k$.\n\nLa rectas $R_k$ son perpendiculares a $c$ y por tanto paralelas entre ellas. \n\nLa curva de nivel $k$ de $z(x)$ es la curva que cumple $z(x) = k$. Y las curvas de nivel de $z(x) = k$ son las rectas $R_k$ para todo $k \\in \\mathbb{R}$.\n\nLa región factible de PL corresponde a la región determinada por los puntos que cumplen todas las restricciones.\n\n### Paso a seguir para la resolución de forma gráfica\n\n1. Representar el conjunto factible\n2. Representar el vector $c$\n3. Representar la recta $R_{k\\*} = c^{T}x = k\\*$ tal que\n    a. Es perpendicular a $c$\n    b. Intersecta el conjunto factible\n    c. $k*$ tiene el valor máximo posible\n4. Elegir un $vértice$ factible que pertenezca a $R_k\\*$ y que llamamos $x\\*$\n5. Determinar las coordenadas exactas de $x\\*$ resolviendo el *sistema lineal* asociado a las restricciones que determinan $x\\*$\n6. El punto óptimo del PL es $x\\*$ y el *beneficio* óptimo es $z(x)$.\n7. En caso de minimizar hacemos lo mismo salvo que en el anterior algoritmo debemos sustitutir $c$ por $-c$.\n\n## Postoptimización\n\nEl análisis de sensibilidad permite conocer si la solución obtenida es sensible a pequeños cambios de los parámetros.\n\n* Recursos limitados: Dado un b ≥ 0, una restriccion ≤ normalmente corresponde a un límite en la disponibilidad de un recurso.\n* Satisfaccion de demandas: Dado un b ≥ 0, una restriccion ≥ normalmente corresponde a la satisfaccion de una demanda.\n* Restricciones de igualdad: Una restriccion de igualdad puede interpretarse como dos restricciones de desigualdad simultaneas y opuestas.\n* Restriccion de no negatividad: x ≥ 0: Aunque es una restriccion, normalmente se interpreta como una declaracion de un tipo de variable.\n\n### Sensibilidad cualitativa\n\n#### Aumento del conjunto factible\n\nSi el nuevo conjunto factible incluye al conjunto factible inicial, el optimo no cambia o mejora.\n\n#### Reduccion del conjunto factible\n\nSi el nuevo conjunto factible esta incluido en el conjunto factible inicial, el optimo no cambia o empeora.\n\n#### Cambios en Right-Hand Side\n\n##### Relajar una restriccion\n\nModificar dicha restricción de forma que el conjunto factible aumente, el óptimo o no cambia o mejora.\n\n##### Tensar una restriccion\n\nModificar dicha restricción de forma que el conjunto factible disminuya, el óptimo o no cambia o empeora.\n\n#### Cambios en A\n\n##### Inclusion de nuevas restricciones\n\nSi en un PL incluimos nuevas restricciones el optimo ser a igual o peor.\n\n##### Eliminacion de restricciones\n\nSi en un PL eliminamos restricciones el optimo ser a igual o mejor.\n\n##### Inclusion de nuevas variables\n\nSi en un PL incluimos nuevas variables el optimo ser a igual o mejor.\n\n##### Eliminacion de variables\n\nSi en un PL eliminamos variables el optimo ser a igual o peor.\n\n### Sensibilidad cuantitativa\n\nEl problema dual es un problema de optimizacion auxiliar que puede ser utilizado para cuantificar la sensibilidad de la solucion primal (óptima) ante cambios en los parametros.\n\n#### Variables duales\n\nSon las variables del problema dual. Tenemos una variable dual $v_i$ por cada restriccion del problema primal, $i \\in I = {1, . . . , m}$.\n\nCada variable dual optima representa la tasa de cambio del coste optimo respecto a cambios en el termino de la derecha de la restricción correspondiente. La variable dual óptima $v^*_i$ puede interpretarse como _precio sombra_ del producto o recurso asociado a la restricción _i_.\n\nCada variable dual optima representa la pendiente de $C_i$($b_i$):\n\n$$\nv^{∗}_i = C^{'}_{i}(bi)\n$$\n\n(excepto en los puntos no derivables).\n\nEl problema dual nos dara sólo los valores de la tasa de cambio del coste optimo correspondiente al b concreto de nuestro problema\n\n$$\nC^{'}_1(b_1), . . . , C^{'}_m(b_m).\n$$\n\n#### Signo de una variable dual\n\n| Primal        | Restriccion i $\\le$ | Restriccion i $\\ge$ | Restriccion i =          |\n| ------------- |:-------------------:|:-------------------:| ------------------------:|\n| Min           | $v_i \\le 0$         | $v_i \\gt 0$         | Sin restricción de signo |\n| Max           | $v_i \\gt 0$         | $v_i \\le 0$         | Sin restricción de signo |\n\n### Formulación del problema dual\n\n![Problema Dual](Problema-Dual.PNG)\n\n### Teoremas de dualidad\n\nUn PL versión minimización (P) y su dual (D)\n\n#### Teorema débil de dualidad\n\nLa función objetivo dual en $\\overline{v}$ es una cota inferior a la función objetivo primal en $\\overline{v}$ y viceversa\n\n### Teorema fuerte de dualidad\n\nSi cualquiera de las dos soluciones es óptima, la otro también y además sus valores óptimos respectivos coinciden.\n\n### Casos factible, infactible y no acotado\n\n* La función objetivo de (P) tiene un valor óptimo finito => La función objetivo de (D) tiene un valor óptimo finito.\n* La función objetivo de (P) no está acotada (inferiormente) => El problema (D) es infactible.\n* La función objetivo de (D) no está acotada (superiormente) => El problema (P) es infactible.\n\n# Programación Entera\n\nLa PLE corresponde a los problemas de Programacion Lineal (PL) donde además se impone la condición de que algunas o todas las variables sean enteras.\n\n[Ejemplo 1](https://github.com/vitaminac/OperationsResearch/blob/master/Integer%20Programming/ejemplo1.gms)\n\n[Ejemplo 2](https://github.com/vitaminac/OperationsResearch/blob/master/Integer%20Programming/ejemplo2.gms)\n\n## Problema de la mochila\n\n### Objetivo\n\nseleccionar un subconjunto óptimo de objetos que maximize la utilidad total\n\n### Variable de decisión\n\n$$\nx_j = \n\\begin{cases}\n      & 1 \\quad \\text{si el objeto j es seleccionado} \\\\\n      & 0 \\quad \\text{en otro caso}\\\\\n\\end{cases}\n$$\n\n### Formulación\n\n$$\n\\begin{split}\n\\max & \\quad c^Tx\\\\\ns.t & \\quad Ax \\le b\\\\\n& \\quad x \\in \\{0,1\\}^n\\\\\n\\end{split}\n$$\n\n[Mochila](https://github.com/vitaminac/OperationsResearch/blob/master/Integer%20Programming/mochila.gms)\n\n## Modelos de asignacion del presupuesto\n\nseleccionar el mejor reparto de un presupuesto entre n proyectos o inversiones bajo m restricciones.\n\n[Proyecto I+D](https://github.com/vitaminac/OperationsResearch/blob/master/Integer%20Programming/proyectoID.gms)\n\n## Modelos de asignación\n\n### Objetivo\n\nAsignar eficientemente un conjunto de trabajadores a un conjunto de tareas.\n\n### Variable de decisión\n\n$$\nx_{ij} =\n\\begin{cases}\n      & 1 \\quad \\text{si el trabajador i se asigna a la tarea j} \\\\\n      & 0 \\quad \\text{en otro caso}\\\\\n\\end{cases}\n$$\n\n### Restricciones\n\n$$\n\\begin{split}\n\\sum_{i=1}^{n}{x_{ij}} &= 1 \\quad \\text{Cada tarea se realiza una vez}\\\\\n\\sum_{j=1}^{n}{x_{ij}} &= 1 \\quad \\text{Cada trabajador realiza una tarea}\\\\\n\\end{split}\n$$\n\n### Formulación\n\n$$\\min \\sum_i{\\sum_j{c_{ij}x_{ij}}}$$\n\n[Abogado](https://github.com/vitaminac/OperationsResearch/blob/master/Integer%20Programming/abogado.gms)\n\n## Modelos de asignación generalizada\n\nEs una generalización del modelo anterior. Cada trabajador puede hacer más de una tarea simultáneamente\n\n### Formulación\n\n$$\n\\begin{split}\nz &= \\min \\sum_i{\\sum_j{c_{ij}x_{ij}}}\\\\\n\\sum_{i=1}^{n}{x_{ij}} &= 1 \\quad \\text{Cada tarea se realiza una vez}\\\\\n\\sum_{j=1}^{n}{a_{ij}x_{ij}} &\\le b_i \\quad \\text{La capacidad maxima de cada trabajador}\\\\\nx_{ij} &\\in \\{0,1\\}\\\\\n\\end{split}\n$$\n\n[Maquinaria](https://github.com/vitaminac/OperationsResearch/blob/master/Integer%20Programming/maquinaria.gms)\n\n## Modelos de la optimización discreta\n\nAlguna o todas variables de un problema deben tomar valores enteros\n\n[Ordenador](https://github.com/vitaminac/OperationsResearch/blob/master/Integer%20Programming/ordenador.gms)\n\n## Problema de cubrimiento y partición\n\n### Parametros\n\n$$\na_{ij} =\n\\begin{cases}\n      & 1 \\quad i \\in S_j\\\\\n      & 0 \\quad \\text{en otro caso}\\\\\n\\end{cases}\n$$\n\n### Restricciones\n\n#### Problema de cubrimiento\n\n$$\n\\sum_{i=1}^{n}{a_{ij}x_{ij}} \\ge 1 \\quad \\text{Cada objeto debe pertenecer al menos a un conjunto}\\\\\n$$\n\n#### Problema de partición\n\n$$\n\\sum_{i=1}^{n}{a_{ij}x_{ij}} = 1 \\quad \\text{Cada objeto debe pertenecer exactamente a un conjunto}\\\\\n$$\n\n[Ambulancia](https://github.com/vitaminac/OperationsResearch/blob/master/Integer%20Programming/ambulancia.gms)\n\n[Cinta](https://github.com/vitaminac/OperationsResearch/blob/master/Integer%20Programming/cinta.gms)\n\n## Diseño de redes\n\n### Objetivo\n\nDecidir qué arcos de una red abrimos de forma que el coste de servicio más costes fijos sea mínimo.\n\n### Formulación\n\n* $A$ conjunto de arcos de la red\n* $ij$ par de indices para los arcos de $A$\n* $V$ conjunto de nodos de la red\n* $k$ indice para los nodos de $V$\n* $x_{ij}$ flujo del arco $ij$\n* $y_{ij}$ es 1 si decidimos conectar $i$ con $j$\n* $b_{k}$ demanda de k\n* $c_{ij}$ coste por unidad de flujo\n* $f_{ij}$ coste de conectar i con j\n* $u_{ij}$ capacidad del arco $ij$\n\n$$\n\\min_{x,y} \\quad z = \\sum_{ij \\in A}{c_{ij}x_{ij}} + \\sum_{ij \\ in A}{f_{ij}y_{ij}} \\quad \\text{coste total}\\\\\ns.a. \\quad \\sum_{ik \\in A}{x_{ik}} - \\sum_{kj \\in A}{x_{kj}} = b_k \\quad \\text{para todo k. (demanda)}\\\\\n0 \\le x_{ij} \\le u_{ij}y_{ij} \\quad \\text{para todo ij (capacidad)}\\\\\ny_{ij} \\in \\{0,1\\} \\text{para todo ij}\n$$\n\n## Localización de plantas\n\n### Objetivo\n\nDecidi qué plantas abrimos de forma que el coste de explotación sea mínimo.\n\n### Formulación\n\n$$\n\\min_{x,y} \\quad z = \\sum_{ij}{c_{ij}d_{j}x_{ij}} + \\sum_{i}{f_{i}y_{i}} \\quad \\text{coste total}\\\\\ns.a. \\sum_{i}{x_{ij}} = 1 \\quad \\text{satisfaccion de la demanda para todo j}\\\\\n\\sum_j{d_j x_{ij} \\le u_i y_i} \\quad \\text{restricciones de capacidad para todo ij}\\\\\nx_{ij} \\ge 0\\\\\ny_{ij} \\in \\{0,1\\}\\\\\n$$\n\n## Problema de viajante\n\n### Variable de decisión\n\n$$\na_{ij} =\n\\begin{cases}\n      & 1 \\quad \\text{si el agente va de la ciudad i a la ciudad j}\\\\\n      & 0 \\quad \\text{en otro caso}\\\\\n\\end{cases}\n$$\n\n### Restricciones\n\n#### El agente debe salir de todas las ciudades\n\n$$\n\\sum_{i}^{n}x_{ij} = 1\\\\\n$$\n\n#### El agente debe llegar a todas las ciudades\n\n$$\n\\sum_{j} x_{ij} = 1\\\\\n$$\n\n#### Eliminación de subciclos\n\n$$\n\\sum_{i \\in S}{\\sum_{j \\not\\in S}} x_{ij} \\ge 1\n$$\n\n## Modelado de condiciones lógica\n\n### Selección múltiple\n\n#### Al menos dos tipos seleccionados\n\n$$\n\\sum_i{\\delta_i} \\ge 2\n$$\n\n#### Exactamente dos tipos seleccionados\n\n$$\n\\sum_i{\\delta_i} = 2\n$$\n\n#### A lo sumo dos tipos seleccionados\n\n$$\n\\sum_i{\\delta_i} \\le 2\n$$\n\n### Costes fijos\n\n$$\n\\delta * coste\n$$\n\n### Variables semicontinuas\n\n$$\nminimo*\\delta \\le x \\le maximo*\\delta\n$$\n\n### Implicaciones\n\n#### 1 o 2 -> 3\n\n$$\\delta_1 + \\delta_2 \\le 2*\\delta_3$$\n\n#### 1 y 2 -> no 3\n\n$$\\delta_1 + \\delta_2 \\le 2 - \\delta_3$$\n\n#### Incompatibilidad\n\n$$\\delta_1 + \\delta_2 \\le 1$$\n\n#### Disyunción\n\n$\\sum_i{a_ix_i} \\le a$ o $\\sum_j{b_jy_j} \\ge b$\n\nSe puede modelar utilizado\n\n$\\sum_i{a_ix_i} \\le a + M\\delta$ y $\\sum_j{b_jy_j} \\ge b + m(1-\\delta)$\n\ncon $M$ suficientemente grande y $m$ suficientemente pequeño\n\n[Aceite](https://github.com/vitaminac/OperationsResearch/blob/master/Integer%20Programming/aceite.gms)\n\n[Petroquímica](https://github.com/vitaminac/OperationsResearch/blob/master/Integer%20Programming/petroquimica.gms)\n\n## Decisiones Multiobjetivo\n\nEn muchos problemas de decisión, es muy complicado o no es imposible transformar todos los objetivos involucrados en un único objetivo\n\n### Puntos eficientes\n\nTambién se denomina punto de pareto, si al moverlo dentro de la región factible para mejorar algún objetivos, tenemos que empeorar al menos otro objetivo.\n\n### Optimización multiobjetivo por suma ponderada de objetivos\n\n$$\nmin \\quad z_1(x)\\\\\n\\vdots\\\\\nmin \\quad z_m(x)\\\\\n$$\n\nen la suma ponderada de objetivos\n\n$$\nmin z(x) = \\sum_{i}\\gamma_i z_i(x)\n$$\n\ndonde cada peso $\\gamma_i$ es un escalar estrictamente positivo para todo $i$.\n\n### Optimizacion multiobjetivo por metas\n\nTranforma siguiente problema\n\n$$\nmeta \\quad z_1(x) \\le m_1\\\\\n\\vdots\\\\\nmeta \\quad z_m(x) \\le m_m\\\\\n$$\n\nen\n\n$$\nmin z(d) = \\sum_{i}\\gamma_i z_i(d_i)\\\\\ns.a. \\quad \nz_1(x) - d_1 \\le m_1\\\\\n\\vdots\\\\\n\\,\\,\\,\\,\\,\\,\\,\\,\\quad\nz_m(x) - d_m \\le m_m\\\\\n$$\n\n[Multiobjetivo](https://github.com/vitaminac/OperationsResearch/blob/master/Integer%20Programming/multiobjetivo.gms)\n\n# Reference\n\n* [Introduction to Operations Research](https://www.amazon.com/dp/1259162982/ref=pd_lpo_sbs_dp_ss_1?pf_rd_p=b4bbef4e-170e-463d-8538-7eff3394b224&pf_rd_s=lpo-top-stripe-1&pf_rd_t=201&pf_rd_i=0073376299&pf_rd_m=ATVPDKIKX0DER&pf_rd_r=327YGFC7GSK9M21G7G3E&pf_rd_r=327YGFC7GSK9M21G7G3E&pf_rd_p=b4bbef4e-170e-463d-8538-7eff3394b224) pag. 32-34",
      "slug": "Programacion-Lineal-Entera",
      "date": "2019-05-30 18:05:04",
      "lang": "es",
      "tags": [
        "Investigación Operativa",
        "Programación Lineal",
        "Programación",
        "Operation Research",
        "Linear Programming"
      ],
      "path": "/Programacion-Lineal-Entera/index.html"
    },
    "lang": "es",
    "_nextI18Next": {
      "initialI18nStore": {
        "es": {
          "common": { "Next": "Siguiente" },
          "feature-tags": {},
          "navbar": {
            "Home": "Inicio",
            "Language": "Lenguaje",
            "Tags": "Tags",
            "en": "Inglés",
            "es": "Español",
            "zh": "Chino"
          },
          "post-layout": { "Author": "Autor: {{author}}", "Tags": "Tags" }
        },
        "en": {
          "common": { "Next": "Next" },
          "feature-tags": {},
          "navbar": {
            "Home": "Home",
            "Language": "Language",
            "Tags": "Tags",
            "en": "English",
            "es": "Spanish",
            "zh": "Chinese"
          },
          "post-layout": { "Author": "Author: {{author}}", "Tags": "Tags" }
        }
      },
      "initialLocale": "es",
      "ns": ["common", "feature-tags", "navbar", "post-layout"],
      "userConfig": {
        "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] },
        "default": {
          "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] }
        }
      }
    }
  },
  "__N_SSG": true
}
