{
  "pageProps": {
    "postData": {
      "title": "La implementación de minishell en Linux",
      "markdownContentSource": "\n# La Implementación de intérprete de mandatos en Linux\n\n## Introducción\n\n¿Qué es un intérprete de mandatos? Es un programa que hace la interfaz en modo texto entre el usuario y el sistema operativo.\n\nEn diferentes distribuciones de GNU/Linux vienen instalado ya por defecto Bash. Un programa informático de interpréte de mandato desarrollado por el proyecto GNU.\n\nMuchas veces en el contexto de empresa y no tenemos el entorno gráfico para gestión y administración de recursos, la única posibilidad es mediante el comando en modo texto.\n\n## Objectivo\n\nNuestro objetivo principal de esta implementación es manajer el concepto del proceso. Su creación, su ciclo de vida, y la intercomunicación necesaria entre proceso.\n\n## Librería de apoyo\n\nPara facilitar la implementación y también para centrar en nuestro objetivo principal. Hemos usado la librería **libparser** que su función primordial es convertir una cadena de caracteres en un struct **tline** que encapsula los comandos que va ejecutar, los argumentos, los redireccionamientos, etc...\n\n## Estructuras de datos utilizadas\n\nEstructuras de datos que vienen con la libraría:\n\n    typedef struct {\n        char * filename;\n        int argc;\n        char ** argv;\n    } tcommand;\n\n    typedef struct {\n        int ncommands;\n        tcommand * commands;\n        char * redirect_input;\n        char * redirect_output;\n        char * redirect_error;\n        int background;\n    } tline;\n\nNuestro:\n\n    /* almacenamos las informaciones asociados a los procesos creados por sistema  */\n    typedef struct JobInfo {\n        int id;\n        pid_t pgid;\n        char * command;\n        struct JobInfo * next;\n    } JobInfo;\n\nEl tipo JobInfo contien información sobre un trabajo que son un serie de trabajo connectado con pipes.\n\n## Funcionamiento general\n\nEl shell debe ser capaz de reconocer y lanzar el programa correspondiente al comando que introduzca el usuario, que es un archivo binario que reside en uno de los directorio que lista en la variable PATH y ejecutarlo con los paramteros que vienen acompañados. \n\nO tambiém una secuencia de comandos conectados enre sí mediante el mecanismo proporcionado por sistema Linux - **pipe**. Y también establecer los redireccionamientos de entrada y de salida si fuera preciso. Y vamos a tener unos cuantos comando interno que se usa para alterar los valores propio del shell.\n\n## Implementación\n\n### Comando básico\n\nLa funcionalidad básica de shell se hace dentro de un while donde lee un línea de texto que introduzca el usuario y parseamos con la librería llamando a la función **tokenize** y procesamos la línea de comandos.\n\n    char buf[BUFFER_SIZE];\n    tline * line;\n\n    do {\n        if (fgets(buf, BUFFER_SIZE, stdin) > 0) {\n            /* Leer una linea del taclado */\n            line = tokenize(buf);\n            if (line == NULL) {\n                continue;\n            }\n\n            execline(line, buf);\n        }\n    } while (true);\n\n\n\nPara hacerlo mas interactivo y también para que el usuario identifique que está detro del shell o en el commando en ejecución. Mostramos una cabecera de shell **msh>** con la función **printf**.\n\n    void prompt() {\n        printf(\"msh:>\");\n    }\n\nCuando tenemos el struct **tline** pasamos a execline donde ejecutamos los comandos correspondientes. La operación más simple sería ejecutar un comando sin redirrecionamiento.\n\n    execvp(command->argv[0], command->argv);\n\n### Redirecionamiento\n\nA veces el usuario pretende que la entra o la salida de programa sea diferente, por ejemplo, un archivo.\n\nTenemos que abrir un archivo que especifica la entra o la salida con la función **open** y luego también redirigirla con la llamada a **dup2**.\n\n    input = open(line->redirect_input, O_RDONLY);\n\n    output = open(line->redirect_output, O_WRONLY | O_CREAT | O_TRUNC, DEFAULT_FILE_CREATE_MODE);\n\n### Comandos encadenados\n\nTambién tenemos la necesidad de realizar varios comandos a la vez y comunicando unos con otraos. Con la llamada **pipe** creamos una tubería que sirve luego en establecer la comunicación entre procesos, y con la llamada **dup2** redireccionamos la salida del comando anterior a la entrada de tubería y desde la salida de la tubería a la entrada estandar para el siguiente comando.\n\n    pipe(pipeline);\n\n    dup2(pipeline[0], STDIN_FILENO);\n    execvp(command->argv[0], command->argv);\n\nY para el siguiente comando cogemos el flujo de entrada y crear otra tubería para si tenemos más comando. Todos estos se puede meter dentro un **for** que iteramos para crear la comunicación entre ellos.\n\n    for (i = 0; i < line->ncommands; i++) {\n        pipe(pipeline)\n        output = pipeline[1];\n        \n        /* ejecutar el comando */\n        execute(&(line->commands[i]), input, output);\n\n        input = pipeline[0];\n    }\n\nEso sería la idea inicial de la secuencia de operaciones que hay que hacer, en la implemención real habría que tener en cuenta más cosa, pj. los redireccionamientos.\n\n### Background\n\nTenemos también la necesidad de distinguir entre los procesos background y los procesos foreground. Lo que hacemos es asginar un id de grupo a los commandos de la misma linea con la función **setpgid**. Y llamamos a **tcsetpgrp** con el valor de grupo si debe ejecutar en el foreground y al terminar volvemos a llamar **tcsetpgrp** y ponemos el shell en foreground. Este procemiento es la forma más estandar de hacer y evitar problema de interferencia con el shell y otros procesos. Evitamos la situación de proceso zombie y también nos permite separar la señal que se envia.\n\n### Debug\n\nPara mejorar la experiencia de la depuración hemos usado el Macro **#ifndef DEBUG**. Siendo la difultad que depurar en el contexto de multiproceso y la posible inferencia entre ellos. Hemos puesto sentencia\n\n    **fprintf(stderr, mensaje de seguimiento);**\n\nCon eso conseguimos tener presente las ultimas operaciones que ha tomado nuestro minishell.\n\nSobre todo nos ayudaría mucho si podemos conseguir obtener el estado de proceso. Hemos creado uana función **debug_wait** que delega la llamada a waitpid pero podemos imprimir informaciones necesarios que queremeos.\n\n### Comando interno\n\n#### cd\n\nAparte de ejecutar los archivos binarios que hay en el sistema. Shell tiene una serie de estado perdeneciente a shell asimismo una serie comando para poder modificar cuyos estados, se conoce como comando interno. **cd** es uno de ello que modifica la ruta actual del programa. **chdir** es una interfaz proporcionada por sistema que permite cumplir dicho deber.\n\n    chdir(line->commands[0].argv[1]);\n\nSi el usuario no especifica con los parametros usamos la variable HOME como directorio de llegada.\n\n    chdir(getenv(\"HOME\"));\n\n#### jobs\n\nAcerca de la gestión de proceso background y foreground. Tenemos que ser capaz de mostrar por pantalla lista de tareas que se está ejecutando en el backgrounp y también.\n\nTenemos definido **struct JobInfo** previamente mencionado, que es una linkedlist que sirve para guardar la lista de procesos que están en ejecución. Cada vez que ejecutamos una línea de comando almacenmos también su informaciones relativas en la lista.\n\n    insert_job(&job_list, new_job(current, strdup(command)));\n\nAl recibir el comando **jobs** lo que hacemos es recorrer la lista siguiendo el puntero de next hasta que acabe la lista.\n\n    current = job_list;\n    while (current != NULL) {\n        print_job(current, i);\n        current = current->next;;\n    }\n\n#### fg\n\nCuando el usuario necesitará traer un proceso en background ejecutará **fg** + **id**. El id sería el numero de aparece cuando muestra con jobs.\n\n    if (current != NULL && current->id == id) {\n        pgid = current->pgid;\n        tcsetpgrp(STDIN_FILENO, pgid);\n        debug_wait(pgid, 0);\n        tcsetpgrp(STDIN_FILENO, shell_pgid);\n    }\n\nPor brevedad no hemos concluido cómo gestionamos la memoria dinámica del shell. Basicamente lo que hacemos es cuando un proceso pasa a foreground o bién que ha terminado libreramos la memeria asosiada a él.\n\n#### Gestión de señal\n\nEl shell es capaz de ejecutar más de un comando en el background. El shell mismo no debe morir ni los procesos background ni el shell. Tenemos que ignoramos tanto SIGINT como SIGQUIT. Lo conseguiremos con **signal**.\n\n    signal(SIGINT, SIG_IGN);\n    signal(SIGQUIT, SIG_IGN);\n\nHemos puesto ese en la inicialización de shell.\n\n#### Más detalle\n\nAquí arriba solo hemos comentado las ideas y la implementación basica de cómo va cada cosa. La gestión real también tenemos que tratar a los posibles errores que sucede mientras ejecutamos la función, la gestión de memoria dinámica, y el control sobre las señales, etc...\n\n## Conclusión\n\nEste trabajo centramos prinpicalmente en el tema de proceso y mecanismo de gestión entre ellos. El problema principal que tuvimos fue gestión la tubería que olvidemos cerrar la tubería en el proceso padre. Que muchas veces no sabemos qué está ocurriendo siendo la dificultad de la depuración es muy alta.",
      "slug": "minishell",
      "date": "2018-12-03 18:05:41",
      "lang": "es",
      "tags": ["Linux", "Shell", "Bash", "Process"],
      "path": "/minishell/index.html"
    },
    "lang": "es",
    "_nextI18Next": {
      "initialI18nStore": {
        "es": {
          "common": { "Next": "Siguiente" },
          "feature-tags": { "Tags": "Tags" },
          "navbar": {
            "Home": "Inicio",
            "Language": "Lenguaje",
            "Tags": "Tags",
            "en": "Inglés",
            "es": "Español",
            "zh": "Chino"
          },
          "post-layout": { "Author": "Autor: {{author}}" }
        },
        "en": {
          "common": { "Next": "Next" },
          "feature-tags": { "Tags": "Tags" },
          "navbar": {
            "Home": "Home",
            "Language": "Language",
            "Tags": "Tags",
            "en": "English",
            "es": "Spanish",
            "zh": "Chinese"
          },
          "post-layout": { "Author": "Author: {{author}}" }
        }
      },
      "initialLocale": "es",
      "ns": ["common", "feature-tags", "navbar", "post-layout"],
      "userConfig": {
        "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] },
        "default": {
          "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] }
        }
      }
    }
  },
  "__N_SSG": true
}
