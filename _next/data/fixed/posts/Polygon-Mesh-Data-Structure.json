{
  "pageProps": {
    "postData": {
      "title": "计算机图形数据结构",
      "markdownContentSource": "\n# 向量\n\n定义:具有大小同时也代表方向的量. 他是几何空间概念中形成的一个抽象的概念. 我们可以用它表示一个三维空间的对象, 例如一个点. \n\n## 坐标\n\n在笛卡尔坐标系下我们使用三个坐标值代表一个向量, \\\\(\\(x, y, z\\)\\\\). \n![三维向量](coordinate.png)\n\n在计算机中我们可以用一个有三个坐标的类表示并储存向量, 每个坐标都用双精度浮点数来表示.\n在 ***vec3.h*** 中, 我定义了个类Vec3用来代表三维向量.\n\n    class Vec3 {\n    public:\n        double x;\n        double y;\n        double z;\n        inline Vec3(const double x, const double y, const double z) : x(x), y(y), z(z)\n        {\n        }\n    };\n\n为了方便以后调试我加了下面的方法把向量打印出来\n\n    ostream& operator<<(ostream& out, const Vec3& v)\n    {\n        out << \"(\" << v.x << \",\" << v.y << \",\" << v.z << \")\";\n        return out;\n    }\n\n### 创建向量-测试\n\n    #include \"vec3.h\"\n\n    int main() {\n        auto v = Vec3(1.0, 2.0, 3.0);\n        std::cout << v << std::endl;\n    }\n\n### 创建向量-输出\n\n(1,2,3)\n\n## 模(向量的大小)\n\n在三维笛卡尔坐标系下的向量$\\vec{a}=(x,y,z)$, \n其模长为 $\\lVert \\vec{a} \\rVert=\\sqrt{x^2+y^2+z^2}$\n\n### 模-实现\n\n    double Vec3::module2() const {\n        return this->x*this->x + this->y*this->y + this->z*this->z;\n    }\n\n    double Vec3::module() const {\n        return sqrt(this->module2());\n    }\n\n### 模-测试\n\n    std::cout << \"The module of \" << a << \" is \" << a.module() << std::endl;\n\n### 模-输出\n\n    The module of (1,2,3) is 3.74166\n\n# 向量的基本运算\n\n向量有两个基本运算: 向量相加和标量乘法\n\n## 向量相加\n\n两个向量$\\vec{a}$和$\\vec{b}$相加会得到另一个向量, 并且具有以下特点, 封闭性, 交换律, 结合律, 零向量, 加法逆元.\n![向量相加](vector_sum.png)\n\n## 向量相减\n\n两个向量$\\vec{a}$和$\\vec{b}$的相减可以看成是加上了一个与$\\vec{b}$大小相等方向相反的向量.\n![向量相减](vector_sub.png)\n\n$$\\vec{a} + \\vec{b} = (a_i + b_i)\\vec{e}_i + (a_j + b_j)\\vec{e}_j + (a_k + b_k)\\vec{e}_k$$\n\n返回一个向量, 它的坐标值是两个向量的各个坐标值的相加或相减\n\n### 向量加减-实现\n\n    Vec3 Vec3::operator+(const Vec3& other) const {\n        return Vec3(this->x + other.x, this->y + other.y, this->z + other.z);\n    }\n\n    Vec3 Vec3::operator-(const Vec3& other) const {\n        return Vec3(this->x - other.x, this->y - other.y, this->z - other.z);\n    }\n\n### 向量加减-测试\n\n    auto a = Vec3(1.0, 2.0, 3.0);\n    auto b = Vec3(1.0, 3.0, 5.0);\n    std::cout << a << \"+\" << b << \"=\" << a + b << std::endl;\n    std::cout << a << \"-\" << b << \"=\" << a - b << std::endl;\n\n### 向量加减-输出\n\n    (1,2,3)+(1,3,5)=(2,5,8)\n    (1,2,3)-(1,3,5)=(0,-1,-2)\n\n## 标量乘法\n\n$k\\vec{v}$, 运算结果是对一个向量的拉伸, 如果k是负数得出的结果会是与$\\vec{v}$方向相反\n\n### 标量乘法-实现\n\n    Vec3 Vec3::operator*(double scalar) const {\n        return Vec3(this->x * scalar, this->y * scalar, this->z * scalar);\n    }\n\n    Vec3 operator*(double scalar, const Vec3 & vector) {\n        return Vec3(vector.x * scalar, vector.y * scalar, vector.z * scalar);\n    }\n\n### 标量乘法-测试\n\n    std::cout << a << \" per 3 is \" << a * 3 << std::endl;\n    std::cout << \"3 per \" << a << \" is \" << 3 * a << std::endl;\n\n### 标量乘法-输出\n\n    (1,2,3) per 3 is (3,6,9)\n    3 per (1,2,3) is (3,6,9)\n\n## 零向量\n\n始点与终点重合, 大小为零的向量$\\vec{0}$\n\n### 零向量-定义\n\n    const Vec3 ZERO_VECTOR = Vec3(0, 0, 0);\n\n## 反向量\n\n一个向量$\\vec{v} (a, b, c)$的反向量$-\\vec{v} (-a, -b, -c)$与它大小相等但方向相反.\n\n### 反向量-实现\n\n    Vec3 Vec3::operator-() const {\n        return Vec3(-this->x, -this->y, -this->z);\n    }\n\n### 反向量-测试\n\n    std::cout << \"The opposite of \" << v << \" is \" << -v << std::endl;\n\n### 反向量-输出\n\n    The opposite of (1,2,3) is (-1,-2,-3)\n\n## 单位向量\n\n单位向量$\\vec{u}$的任意向量$\\vec{a}$, 它的方向与$\\vec{a}$相同, 长度为1.\n$$ \\vec{u}=\\frac{\\vec{a}}{\\lVert \\vec{a} \\rVert} $$\n\n### 单位向量-实现\n\n    Vec3 Vec3::normalize() const {\n        double length = this->module();\n        return Vec3(\n            this->x / length,\n            this->y / length,\n            this->z / length\n        );\n    }\n\n### 单位向量-测试\n\n    std::cout << \"The unit vector of \" << a << \" is \" << a.normalize() << std::endl;\n\n### 单位向量-输出\n\n    The unit vector of (1,2,3) is (0.267261,0.534522,0.801784)\n\n# 向量的点积和叉积\n\n## 点积\n\n代数运算 $\\vec{a}*\\vec{b}=\\sum_{i=1}^{n}{a_i b_i}$.\n\n几何定义 $\\vec{a}*\\vec{b}=|\\vec{a}| |\\vec{v}| cos \\theta$.\n\n![点乘的几何意义](dot_product.png)\n\n### 点积-实现\n\n    double Vec3::operator*(const Vec3 & other) const {\n        return this->x * other.x + this->y * other.y + this->z * other.z;\n    }\n\n### 点积-测试\n\n    std::cout << \"The dot product of \" << a << \" with \" << b << \" is \" << a * b;\n\n### 点积-输出\n\n    The dot product of (1,2,3) with (1,3,5) is 22\n\n## 向量积(叉积)\n\n运算结果是个向量\n![向量积的几何意义](dot_product.png)\n\n计算方式\n\n$$\n\\vec{a} \\times \\vec{b} = \n\\begin{bmatrix}\n\\vec{i} & \\vec{j} & \\vec{k} \\\\\na_x     &  a_y    & a_z     \\\\\nb_x     &  b_y    & b_z     \\\\\n\\end{bmatrix}\\\\\na \\times b = (a_yb_z-a_zb_y)\\vec{i} - (a_xb_z-a_zb_x)\\vec{j} + (a_xb_y-a_yb_x)\\vec{k}\n$$\n\n### 向量积-实现\n\n    Vec3 Vec3::cross(const Vec3 & other) const {\n        return Vec3(\n            this->y * other.z - this->z * other.y,\n            -(this->x * other.z - this->z * other.x),\n            this->x*other.y - this->y*other.x\n        );\n    }\n\n### 向量积-测试\n\n    std::cout << \"The cross product of \" << a << \" with \" << b << \" is \" << a.cross(b) << std::endl;\n    std::cout << \"The cross product of \" << b << \" with \" << a << \" is \" << b.cross(a) << std::endl;\n\n### 向量积-输出\n\n    The cross product of (1,2,3) with (1,3,5) is (1,-2,1)\n    The cross product of (1,3,5) with (1,2,3) is (-1,2,-1)\n\n## 夹角\n\n$$\n\\arctan\n\\Bigg(\n\\frac\n{\n\\frac\n{\\lVert \\vec{u} \\times \\vec{v} \\rVert}\n{\\sqrt{(\\vec{u}*\\vec{u})*(\\vec{v}*\\vec{v})}}\n}\n{\n\\frac\n{\\vec{u} * \\vec{v}}\n{\\sqrt{(\\vec{u}*\\vec{u})*(\\vec{v}*\\vec{v})}} \n}\n\\Bigg)\n$$\n\n### 夹角-实现\n\n    double Vec3::includedAngle(Vec3 & v) const {\n        // compute |u| * |v|\n        double divisor = sqrt(this->operator*(*this) * (v * v));\n        double cosine = this->operator*(v) / divisor;\n        double sine = this->cross(v).module() / divisor;\n\n        return atan2(sine, cosine);\n    }\n\n### 夹角-测试\n\n    std::cout << \"The angle between \" << a << \" and \" << b << \" is \" << a.includedAngle(b) << std::endl;\n\n\n### 夹角-输出\n\n    The angle between (1,2,3) and (1,3,5) is 0.110884\n\n# 三角网格\n\n三角网格是多边形网格(Mesh)的一种, 是一种在计算机图形中用来模拟物体表面的数据结构. 在计算机中现实世界的曲面是用大量的小三角形片去组成的. 由于多边形实际上也能细分成三角形, 所以使用三角网格(Triangle Mesh)是一种比较常见的情况.\n![三角网格](triangle_mesh.png)\n\n## 索引三角网格\n\n为了表示网格我们需要定义点和三角形的数据结构, \n点可以用向量, 三角形则保存三个点的索引\n\n    class Triangle {\n    public:\n        unsigned int a;\n        unsigned int b;\n        unsigned int c;\n\n        inline Triangle(unsigned int a, unsigned int b, unsigned int c) :a(a), b(b), c(c) {\n        }\n    };\n\n这些索引指向的是存储在网格中的顶点, 我们必须知道对应是哪个网格三角片才会具有意义.\n在网格中我们需要维护两个列表, 顶点表和三角形表\n\n    class TriangleMesh {\n    public:\n        std::vector<Vec3> vertices;\n        std::vector<Triangle> faces;\n    };\n\n### 调试三角网格\n\n    std::ostream& operator << (std::ostream & os, const Triangle& t) {\n        os << \"the Triangle a:\" << t.a << \", b:\" << t.b << \", c: \" << t.c;\n        return os;\n    }\n\n    std::ostream& operator << (std::ostream & os, const TriangleMesh& mesh) {\n        os << \"the mesh has \" << mesh.vertices.size() << \" vertices and \" << mesh.faces.size() << \" faces\" << std::endl;\n        for (auto &v : mesh.vertices) {\n            os << v << std::endl;\n        }\n        for (auto &f : mesh.faces) {\n            os << f << std::endl;\n        }\n        return os;\n    }\n\n## 储存方式\n\n### .obj\n\n每一行代表一个点v或者面f\n\n    v 0.0624 0.03942 0.03357\n    v 0.0769 0.03909 0.03235\n    v 0.0569 0.03902 0.03239\n    v 0.0332 0.03602 0.03412\n\n    f 1 2 3\n    f 3 2 4\n    f 1 3 4 \n\n### .off\n\n[下载测试文件](16Triangles.off)\n第一行的头部数据是顶点, 面, 边的数量\n\n    OFF 4 3 6\n    0.0624 0.03942 0.03357\n    0.0769 0.03909 0.03235\n    0.0569 0.03902 0.03239\n    0.0332 0.03602 0.03412\n    3 0 1 2\n    3 2 1 3\n    3 0 2 3\n\n#### 解析.off文件\n\n    void TriangleMesh::importFromOff(std::istream &is) {\n        std::string header;\n        // read header\n        if (!(is >> header))\n            throw std::string(\"error loading header\");\n\n        //Check if header ends with \"OFF\"\n        if (header.length() < 3 || header.compare(header.length() - 3, 3, \"OFF\"))\n        {\n            std::cerr << \"Header: \" << header << std::endl;\n            throw std::string(\"file is not in OFF file format.\");\n        }\n\n        // Read the number of vertex, faces, edges\n        unsigned int nv, nf, ne;\n        if (!(is >> nv >> nf >> ne)) {\n            throw std::string(\"error loading number of vertex, faces and edges\");\n        }\n\n        std::cerr << \"vertex: \" << nv << \" faces: \" << nf << \" edges: \" << ne << std::endl;\n\n        this->vertices.reserve(nv);\n        this->faces.reserve(nf);\n\n        // read the values of vertex\n        for (int i = 0; i < nv; i++) {\n            double x, y, z;\n            if (!(is >> x >> y >> z))\n                throw std::string(\"error loading coordinates\");\n            this->vertices.push_back(Vec3(x, y, z));\n        }\n\n        // read the values of triangles\n        for (int i = 0; i < nf; i++)\n        {\n            unsigned int n, a, b, c;\n            //Read values for indexes\n            if (!(is >> n >> a >> b >> c))\n                throw std::string(\"error loading triangles\");\n\n            //Check it a triangle mesh\n            if (n != 3)\n            {\n                std::cerr << \"Face: \" << i << std::endl;\n                throw std::string(\"This reader only support triangle faces\");\n            }\n\n            //Check some errors\n            if (a < 0 || b < 0 || c < 0 || a >= nv || b >= nv || c >= nv)\n            {\n                std::cerr << \"Triangle: \" << i << \" -> \" << a << \" \" << b << \" \" << c << std::endl;\n                throw std::string(\"Invalid value for index\");\n            }\n\n            this->faces.push_back(Triangle(a, b, c));\n        }\n    }\n\n### 文件解析测试\n\n    TriangleMesh mesh;\n    std::ifstream off_in(\"16Triangles.off\");\n    std::cout << \"Reading file 16Triangles.off\" << std::endl;\n    mesh.importFromOff(off_in);\n    std::cout << \"The mesh was restored\" << std::endl << mesh;\n\n### 文件输出测试\n\n    The mesh was restored\n    the mesh has 15 vertices and 16 faces\n    (0,-0.942809,0)\n    (0,1.88562,0)\n    (0.816495,0.471406,0)\n    (-0.816495,0.471406,0)\n    (1.63299,-0.942809,0)\n    (-1.63299,-0.942809,0)\n    (0,0.648183,0)\n    (-0.56134,-0.32409,0)\n    (0.56134,-0.32409,0)\n    (0.408248,1.35529,0)\n    (-0.408248,1.35529,0)\n    (0.969588,-1.0312,0)\n    (1.37784,-0.32409,0)\n    (-1.37784,-0.32409,0)\n    (-0.969588,-1.0312,0)\n    the Triangle a:6, b:7, c: 8\n    the Triangle a:6, b:3, c: 7\n    the Triangle a:3, b:6, c: 10\n    the Triangle a:6, b:9, c: 10\n    the Triangle a:8, b:11, c: 12\n    the Triangle a:7, b:13, c: 14\n    the Triangle a:2, b:6, c: 8\n    the Triangle a:8, b:7, c: 0\n    the Triangle a:6, b:2, c: 9\n    the Triangle a:10, b:9, c: 1\n    the Triangle a:2, b:8, c: 12\n    the Triangle a:8, b:0, c: 11\n    the Triangle a:12, b:11, c: 4\n    the Triangle a:0, b:7, c: 14\n    the Triangle a:7, b:3, c: 13\n    the Triangle a:14, b:13, c: 5\n\n### 保存为.off文件\n\n    void TriangleMesh::saveAsOff(std::ostream & os) {\n        // write the header\n        os << \"OFF\" << \"\\n\" << this->vertices.size() << \" \" << this->faces.size() << \" \" << 0 << \"\\n\";\n\n        // write vertices\n        for (auto & v : this->vertices) {\n            os << v.x << \" \" << v.y << \" \" << v.z << \"\\n\";\n        }\n        // write triangles\n        for (auto & t : this->faces) {\n            os << \"3 \" << t.a << \" \" << t.b << \" \" << t.c << \"\\n\";\n        }\n    }\n\n### 保存测试\n\n    std::ofstream off_out(\"16Triangles_out.off\");\n    std::cout << \"Saving as the .off format\" << std::endl;\n    mesh.saveAsOff(off_out);\n\n### 保存输出\n\n    Saving as the .off format\n\n# 三角面的运算\n\n## 三角面积\n\n![三角面面积](triangle_area.jpg)\n\n$$\narea = \\frac{\\vec{u} \\times \\vec{v}}{2}\n$$\n\n### 三角面积-实现\n\n    double TriangleMesh::facetArea(Triangle & f) const {\n        auto a = this->vertices[f.a];\n        auto b = this->vertices[f.b];\n        auto c = this->vertices[f.c];\n\n        auto u = b - a;\n        auto v = c - a;\n\n        return u.cross(v).module() / 2;\n    }\n\n### 三角面积-测试\n\n    std::cout << \"The surface' area of \" << mesh.faces[0] << \" is \" << mesh.facetArea(mesh.faces[0]) << std::endl;\n\n### 三角面积-输出\n\n    The surface' area of the Triangle a:6, b:7, c: 8 is 0.545776\n\n## 三角面的法向量\n\n![三角面法向量](triangle_normal.png)\n\n$$\n    \\hat{n} = \\frac{e_1 \\times e_2}{\\lVert e_1 \\times e_2 \\rVert}\n$$\n\n### 三角面法向量-实现\n\n    Vec3 TriangleMesh::surfaceNormal(const Triangle & t) const {\n        auto a = this->vertices[t.a];\n        auto b = this->vertices[t.b];\n        auto c = this->vertices[t.c];\n\n        auto u = b - a;\n        auto v = c - a;\n\n        return u.cross(v).normalize();\n    }\n\n### 三角面法向量-测试\n\n    std::cout << \"The surface normal associated with \" << mesh.faces[0] << \" is \" << mesh.surfaceNormal(mesh.faces[0]) << std::endl;\n\n### 三角面法向量-输出\n\n    The surface normal associated with the Triangle a:6, b:7, c: 8 is (0,0,1)\n\n## 顶点法向量\n\n 顶点处其实是没有法向量定义的, 在这些地方标注了网格不连续的地方.\n 一个近似方法使用平均相邻三角面的法向量并将结果标准化.\n 但是在某些情况下, 其结果并不是所期望的. \n 例如如果使用平均三角形法向量计算顶点的法向量, 那些边缘特性会被平滑化.\n\n### 顶点法向量-实现\n\n    Vec3 TriangleMesh::vertexNormal(unsigned int index) const {\n        Vec3 norm = ZERO_VECTOR;\n        for (auto & f : this->faces) {\n            if (f.a == index || f.b == index || f.c == index) {\n                norm = norm + this->surfaceNormal(f);\n            }\n        }\n        return norm.normalize();\n    }\n\n### 顶点法向量-测试\n\n    std::cout << \"The vertex normal associated with vectex 0 \" << mesh.vertices[0] << \" is \" << mesh.vertexNormal(0) << std::endl;\n\n### 顶点法向量-输出\n\n    The vertex normal associated with vectex 0 (0,-0.942809,0) is (0,0,1)\n",
      "slug": "Polygon-Mesh-Data-Structure",
      "date": "2018-11-11 22:14:47",
      "lang": "zh",
      "tags": ["计算机图形", "三角网格", "向量", "几何", "图形结构"],
      "path": "/Polygon-Mesh-Data-Structure/index.html"
    },
    "lang": "zh",
    "_nextI18Next": {
      "initialI18nStore": {
        "zh": {
          "common": { "Next": "下一页" },
          "feature-tags": {},
          "navbar": {
            "Home": "主页",
            "Language": "语言",
            "Tags": "标签",
            "en": "英语",
            "es": "西语",
            "zh": "中文"
          },
          "post-layout": { "Author": "作者: {{author}}", "Tags": "标签" }
        },
        "en": {
          "common": { "Next": "Next" },
          "feature-tags": {},
          "navbar": {
            "Home": "Home",
            "Language": "Language",
            "Tags": "Tags",
            "en": "English",
            "es": "Spanish",
            "zh": "Chinese"
          },
          "post-layout": { "Author": "Author: {{author}}", "Tags": "Tags" }
        }
      },
      "initialLocale": "zh",
      "ns": ["common", "feature-tags", "navbar", "post-layout"],
      "userConfig": {
        "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] },
        "default": {
          "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] }
        }
      }
    }
  },
  "__N_SSG": true
}
