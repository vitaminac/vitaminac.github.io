{
  "pageProps": {
    "postData": {
      "title": "Hacer Una Libreria C",
      "markdownContentSource": "\n[Libraría.h](https://github.com/vitaminac/code/blob/master/competition/so/libreria.h)\n\n## Interfaz de Usuario\n\nEsta práctica consiste en implementar una librería en el lenguaje de programación C. con tres funciones, head, tail y longline, que muestran las N líneas por la salida estándar. Existe las diferentes opciones. La siguiente pantalla muestra la ayuda cuando el usuario no haya pasado ningún argumento.\n\n![Menu](menu.png)\n\nEl valor de N es opcional, si no especificamos el valor N, por defecto es 5.\n\nLuego nos pedirá que introduzcamos algunas líneas con el teclado.\n\n![Head](head.png)\n\nPara simplificar el testeo del programa hemos usado pipe.\n\nEsta pantalla es un ejemplo en el que le damos la entrada y le pedimos que muestre las 10 líneas por la salida estándar. La entrada que le pasamos es el resultado del comando ps aux mediante pipe, que es la lista de los procesos en ejecución.\n\n![Tail](tail1.png)\n\nEste ejemplo es lo mismo que antes solo que le pedimos que muestre más líneas. \n\n![Tail](tail2.png)\n\nSi la entrada que le pasamos no tiene suficientes líneas, es decir, menos que N. Muestra todos sus contenidos.\n\nSi los argumentos que haya pasado son ilegales muestra un mensaje de error.\n\n![Long](long.png)\n\n## Descripción de código\n\n### Head\n\nLa función head muestra las N primeras líneas en la salida estándar recibidas por la entrada.\nNecesitamos una estructura de dato que nos permite guardar los caracteres leídos de una línea. Utilizamos un puntero a una cadena de caracteres, char * line.\nReservamos malloc un tamaño mínimo del buffer, capacity y lo multiplicamos por tamaño de cada caracter sizeof(char) para establecer el tamaño de la línea, si la línea que tenemos que leer supera la capacidad actual, duplicamos realloc la capacidad del buffer.\nTambién necesitamos una variable entera length que se utiliza como longitud actual de la línea e ir incrementando length++ cuando leemos más caracteres getchar, si supera el tamaño de buffer duplicamos. También hemos hecho la comprobación de que si existe suficiente memoria para leer dichas líneas.\nEs posible que la entrada que nos pase no contiene menos de N líneas. Por eso tenemos que dividir en casos y hacer el control.\nCuando llega al final de una línea, guardamos un null char ‘\\0’ en la última posición, reiniciar las variables de control length=0, ponemos el resultado de la línea leído en la salida y seguir leyendo hasta N líneas. Al final de la función necesitamos liberar el puntero.\n\n### Tail\n\nLa función tail muestra las N últimas líneas en la salida estándar recibida por la entrada.\nEs similar a la función head la estructura de dato que utilizamos es una lista de cadena de caracteres char **, entendemos a cadena de caracteres como una cadena de caracteres char *. La capacidad de la lista es N y la capacidad de cada cadena está limitado por una variable capacities. Duplicamos automáticamente el tamaño si es necesario.\n \nAdemás de una variable para indicar la longitud de la línea actual characterNumber. También tenemos que añadir un índice para llevar la cuenta de líneas leidos lineNumber. \n\nPrimero inicializamos la lista de N cadena, vamos leyendo carácter a carácter, cada vez que leemos un carácter aumentamos la variable characterNumber. Si llega al carácter de cambio de línea ‘\\n’ añadimos null char al final, reiniciamos el valor carácterNumber a 0, aumentamos lineNumber, y guardamos la línea en la position lineNumber módulo N, así conseguimos reemplazar la última línea laida. Cuando lea la N+1 líneas puedan sustituir la primera línea. Y así cuando llegue al final EOF, envía los N últimos línea leídas al.\n\n### Longlines\n\nLa función longlines muestra las N líneas más largas recibidas de forma orden de mayor a menor, o todas ellas si hay menos de N líneas, por la entrada de forma ordenada en la salida estándar. Empleamos un procedimiento similar como hacemos en tail. Y cuando el usuario introduzca más de N líneas comprobamos que es más larga que la línea más corta y reordenamos en caso necesario.\n\n[Libraría.c](https://github.com/vitaminac/code/blob/master/competition/so/libreria.c)\n",
      "slug": "Hacer-Una-Libreria-C",
      "date": "2019-11-05 00:14:26",
      "lang": "es",
      "tags": ["Systema Operativo"],
      "path": "/Hacer-Una-Libreria-C/index.html"
    },
    "lang": "es",
    "_nextI18Next": {
      "initialI18nStore": {
        "es": {
          "common": { "Next": "Siguiente" },
          "feature-tags": { "Tags": "Tags" },
          "navbar": {
            "Home": "Inicio",
            "Language": "Lenguaje",
            "Tags": "Tags",
            "en": "Inglés",
            "es": "Español",
            "zh": "Chino"
          },
          "post-layout": { "Author": "Autor: {{author}}" }
        },
        "en": {
          "common": { "Next": "Next" },
          "feature-tags": { "Tags": "Tags" },
          "navbar": {
            "Home": "Home",
            "Language": "Language",
            "Tags": "Tags",
            "en": "English",
            "es": "Spanish",
            "zh": "Chinese"
          },
          "post-layout": { "Author": "Author: {{author}}" }
        }
      },
      "initialLocale": "es",
      "ns": ["common", "feature-tags", "navbar", "post-layout"],
      "userConfig": {
        "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] },
        "default": {
          "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] }
        }
      }
    }
  },
  "__N_SSG": true
}
