{
  "pageProps": {
    "postData": {
      "title": "Matrices in Computer Graphics",
      "markdownContentSource": "\n# Matrix Transformations\n\nThe matrices are used frequently in computer graphics and the matrix transformations are one of the core mechanics of any 3D graphics, the chain of matrix transformations allows rendering a 3D object on a 2D monitor.\n\n## Affine Space\n\nAn affine space is a generalization of vector space where there is not a notion of an origin. Affine space works with points and vectors where translations are allowed.\n\n## Affine transformation\n\nAn affine transformation is a function that maps points from one affine space to another, preserving affine properties like parallelism, ratio of lengths for parallel line segments. Affine transformations include: **scaling**, **rotation**, **translation**, **reflection**, **shearing**. In geometry, an affine transformation can be represented as the composition of a linear transformation plus a translation. If we want to perform any affine transformation using matrix form, the representation of 3D Euclidean vector space is not enough. We can use **4D homogeneous space** to represent the 3D Euclidean affine space. We extend our vectors to four-dimension and using **4x4 matrix** to represent affine transformation.\n\n## 4D Homogeneous Space\n\nThe fourth component in a 4D vector is $w$, sometimes referred to as the **homogeneous coordinate**. Image the standard 2D plane such that any 2D point $(x, y)$ is represented in homogeneous 3D space $(x, y, 1)$. There are an infinite points in homogeneous space $(kx, ky, k)$, $k \\ne 0$, these points form a line through the origin.  For all points that are not in the plane $w=1$, we can project the point onto the standard plane by dividing by $w$. So the homogeneous coordinate $(x, y, w)$ is mapped to the 2D point $(x/w, y/w)$.\n\n![Projecting homogeneous coordinates](Projecting.png)\n\nWhen $w = 0$, we can interpret as a **direction**. The **location** where $w \\ne 0$ are **points** and the **directions** with $w = 0$ are **vectors**. If assume for the moment that $w$ is always 1, any 3 x 3 transformation matrix can be represented in 4D homogeneous space by using the conversion.\n\n$$\n\\begin{bmatrix}\nm_{11} & m_{12} & m_{13} & 0\\\\\nm_{21} & m_{22} & m_{23} & 0\\\\\nm_{31} & m_{32} & m_{33} & 0\\\\\n0 & 0 & 0 & 1\\\\\n\\end{bmatrix}\n$$\n\n## Scaling Matrices\n\n![Scaling a 2D object with various factors for k_x and k_y](scaling-2D.png)\n\nGiven $\\vec{k}=(k_i, k_j, k_z)$ is a 3D vector that represent the scale along each axis. The 3D homogeneous scale matrix is\n\n$$\nS(\\vec{k}) =\n\\begin{bmatrix}\nk_x & 0 & 0 & 0\\\\\n0 & k_y & 0 & 0\\\\\n0 & 0 & k_z & 0\\\\\n0 & 0 & 0 & 1\\\\\n\\end{bmatrix}\n$$\n\nThe scaled vector will be\n\n$$\np^\\prime = S(\\vec{k})p\n$$\n\n[Scaling](https://github.com/vitaminac/minige/blob/96ea43c5caae8099cb8faa6129f9598614318df4/src/geometry/mat4.cpp#L104-L111)\n\n## Rotation Matrices\n\nIn 3D, rotation occurs about a **axis** and $\\theta$ is the angle using the **right-hand rule**(**counterclockwise direction**). The rotations can also be represented by clockwise direction.\n\n$$\np^\\prime = \\textbf{R}(\\hat{\\textbf{n}},\\theta)p\n$$\n\n$$\n\\textbf{R}_x(\\theta) =\n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & \\cos\\theta & -\\sin\\theta\\\\\n0 & \\sin\\theta & \\cos\\theta\\\\\n\\end{bmatrix}\n$$\n\n$$\n\\textbf{R}_y(\\theta) =\n\\begin{bmatrix}\n\\cos\\theta & 0 & \\sin\\theta\\\\\n0 & 1 & 0\\\\\n-\\sin\\theta & 0 & \\cos\\theta\\\\\n\\end{bmatrix}\n$$\n\n$$\n\\textbf{R}_z(\\theta) =\n\\begin{bmatrix}\n\\cos\\theta & -\\sin\\theta & 0\\\\\n\\sin\\theta & \\cos\\theta & 0\\\\\n0 & 0 & 1\\\\\n\\end{bmatrix}\n$$\n\n![Rotation](rotation.gif)\n\nFor an arbitrary axis in 3D, the rotation matrix $\\textbf{R}(\\hat{\\textbf{n}}, \\theta)$ is\n\n$$\n\\begin{bmatrix}\nn_x^2 (1 - \\cos \\theta) + \\cos \\theta & n_x n_y (1 - \\cos \\theta) - n_z \\sin \\theta & n_x n_z (1 - \\cos \\theta) + n_y \\sin \\theta\\\\\nn_x n_y (1 - \\cos \\theta) + n_z \\sin \\theta & n_y^2 (1 - \\cos \\theta) + \\cos \\theta & n_y n_z (1 - \\cos \\theta) - n_x \\sin \\theta\\\\\nn_x n_z (1 - \\cos \\theta) - n_y \\sin \\theta & n_y n_z (1 - \\cos \\theta) + n_x \\sin \\theta & n_z^2 (1 - \\cos \\theta) + \\cos \\theta\\\\\n\\end{bmatrix}\n$$\n\n[Rotation](https://github.com/vitaminac/minige/blob/96ea43c5caae8099cb8faa6129f9598614318df4/src/geometry/mat4.cpp#L76-L102)\n\n## Refletion Matrix\n\nReflection (also called mirroring) is a transformation that ‚Äúflips‚Äù the object about a line (in 2D) or a plane (in 3D).\n\n![Reflection](Reflection.png)\n\nReflection can be accomplished by applying a scale factor of $-1$. For the transformation to be linear, the plane must contain the origin.\n\n$$\np^\\prime = \\textbf{R}(\\hat{\\textbf{n}})p\n$$\n\n$$\n\\textbf{R}(\\hat{\\textbf{n}}) =\n\\begin{bmatrix}\n1 - 2 n^2_x & -2 n_x n_y & -2 n_x n_z\\\\\n-2 n_x n_y & 1 - 2 n^2_y & -2 n_y n_z\\\\\n-2 n_x n_z & -2 n_y n_z & 1 - 2 n^2_z\\\\\n\\end{bmatrix}\n$$\n\n## Shearing Matrix\n\nShearing is a transformation that ‚Äúskews‚Äù the coordinate space, stretching it non-uniformly. Angles are not preserved; however, surprisingly, areas and volumes are.\n\n![Shearing](Shearing.png)\n\n$$\n\\textbf{H} =\n\\begin{bmatrix}\n1 & s^y_x & s^z_x\\\\\ns^x_y & 1 & s^z_y\\\\\ns^x_z & s^y_z & 1\\\\\n\\end{bmatrix}\n$$\n\n$$\nx^\\prime = x + s^y_x y + s^z_x z\\\\\ny^\\prime = s^x_y x + y + s^z_y z\\\\\nz^\\prime = s^x_z x + s^y_z y + z\\\\\n$$\n\n## Translation Matrix\n\nWith 4x4 Matrix, we can also express translation as a matrix multiplication that represent the position where we want to move our space to, which we can use to head move the camara or to move objects.\n\n$$\np^\\prime = T(\\vec{d})p\n$$\n\n$$\nT(\\vec{d}) =\n\\begin{bmatrix}\n1 & 0 & 0 & d_x\\\\\n0 & 1 & 0 & d_y\\\\\n0 & 0 & 1 & d_z\\\\\n0 & 0 & 0 & 1\\\\\n\\end{bmatrix}\n$$\n\n![Translation](translation.png)\n\n[Translation](https://github.com/vitaminac/minige/blob/96ea43c5caae8099cb8faa6129f9598614318df4/src/geometry/mat4.cpp#L68-L75)\n\n## Compositions of Transformations\n\nWe can chain several transformations together by multiplying matrices in order, the result will be a single matrix that encodes the full transformation.\n\nLet $T$ be translation matrix and $\\vec{d}$ be a translation vector, $L$ as linear transformation about the axes, the corresponding matrix is\n\n$$\nA = T\n\\begin{bmatrix} \nL & 0\\\\\n0 & 1\\\\\n\\end{bmatrix} =\n\\begin{bmatrix} \nL & 0\\\\\n0 & 1\\\\\n\\end{bmatrix}\nT =\n\\begin{bmatrix}\nL & \\vec{d}\\\\\n0 & 1\\\\\n\\end{bmatrix}\n$$\n\nThen we could compute a new point $p^\\prime$ by $p^\\prime = A p$. $L$ can be any combination of scaling, rotation, reflection, shearing matrix but the order of application matter.\n\n## Model Matrix\n\nEvery model in the game lives in its specific vector space, called **model space**. All the vertices are relative to the origin of the **model space**, if we want them to be in any spatial relation we need **model matrix** to transform them into a common space which is called **world space**. Since every object will be in its own position and orientation in the world, we will need a different **model matrix** for each object to scale it, rotate it and move it to the desired position and orientation with appropriate size. When all the objects have been transformed into a common space, their vertices will then be relative to the **world space**.\n\n## View Matrix\n\nWe use **view matrix** to transform into an auxiliary space **view space** is that simplifies a lot the math if we could have the camera centered in the origin and watching down one of the three axis. In OpenGL, by default, the camera is at the coordinate origin, facing towards -z and with the vector up oriented with the y-axis.\n\n![Camera](camera.png)\n![Camera Space](camera-space.png)\n\n## Projection Matrix\n\nThe **view frustum** is the volume of space that is potentially visible to the camera. The view frustum is bounded by six planes, known as the clip planes, top, left, bottom, right, near and far planes. The near and far clip planes, which correspond to certain camera-space values of z. The reason for the far clip plane is prevents rendering of objects beyond a certain distance. A far clip plane can limit the number of objects that need to be rendered in an outdoor environment. The far clip establishes what (floating point) z value in camera space will correspond to the maximum value that can be stored in the depth buffer.\n\n![Perspective View Frustum](perspective-view-frustum.png)\n![Orthographic View Frustum](orthographic-view-frustum.png)\n\nTo facilitate the transformation of points in **view frustum** to pixels, we use **projection matrix** to map the **view frustum** into the **homogeneous clip space**.\n\n### Orthographic Projection\n\nIn the orthographic projection, also known as a parallel projection, the lines from the original point to the resulting projected point on the plane are parallel to the camera's viewing direciton.\n\n![Orthographic Projection](orthographic-projection.png)\n\nThe orthographic frustum is\n\n$$\n\\begin{split}\nM_{\\text{orthographic projection}} &= ST\\\\\n&=\n\\begin{bmatrix}\n\\frac{2}{right - left} & 0 & 0 & 0\\\\\n0 & \\frac{2}{top - bottom} & 0 & 0\\\\\n0 & 0 & \\frac{2}{far - near} & 0\\\\\n0 & 0 & 0 & 1\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 & -\\frac{left + right}{2}\\\\\n0 & 1 & 0 & -\\frac{top + bottom}{2}\\\\\n0 & 0 & -1 & -\\frac{far + near}{2}\\\\\n0 & 0 & 0 & 1\\\\\n\\end{bmatrix}\n\\\\\n&=\n\\begin{bmatrix}\n\\frac{2}{right - left} & 0 & 0 & -\\frac{right + left}{right - left}\\\\\n0 & \\frac{2}{top - bottom} & 0 & -\\frac{top + bottom}{top - bottom}\\\\\n0 & 0 & -\\frac{2}{far - near} & -\\frac{far + near}{far - near}\\\\\n0 & 0 & 0 & 1\\\\\n\\end{bmatrix}\n\\\\\n\\end{split}\n$$\n\n[Orthographic Projection](https://github.com/vitaminac/minige/blob/2011e5b8c7d833e67ddab40aa28a7e511a2aae5b/src/geometry/mat4.cpp#L113-L126)\n\nThe projection on a 2x2 plane parallel to the XY plane that passes through the point z = -D is\n\n$$\n\\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & -D\\\\\n0 & 0 & 0 & 1\\\\\n\\end{bmatrix}\n$$\n\n### Perspective Projection\n\nWith perspective projection, the projectors intersect at the **center of projeciton**.\n\n![Center of projeciton](center-of-projection.png)\n\nDue to perpective foreshortening, the projecion on the left is larger than the projection on the right. The left-hand is closer to the projection plane. As we move an object farther away from the center of projection, its orthographic projection remains constant, but the perspective projection gets smaller. The projectors cross the center of projection and the image is inverted when striking the plane.\n\n![Perspective foreshortening](perspective-foreshortening.png)\n\nBy similar triangles, we know\n\n![Projection plane from the side](projection-plane-negative.png)\n\n$$\n\\begin{split}\np\\prime_x &= \\frac{-dp_x}{z}\\\\\np\\prime_y &= \\frac{-dp_y}{z}\\\\\n\\end{split}\n$$\n\nThe $z$ value of all the projected points are the same $-d$. Thus the result of projecting a point $\\textbf{p}$ through the origin onto a plane at $z=-d$ is\n\n$$\np = (x, y, z) \\Rightarrow p^\\prime = (-dx/z, -dy/z, -d)\n$$\n\n![Projection plane from other side](projection-plane-positive.png)\n\nif we move the plane of projeciton to $z=d$, we will have\n\n$$\np^\\prime = [dx/z \\quad, dy/z \\quad d]\n$$\n\nThe projection on a plane parallel to the XY plane that passes through the point z = -D with the camera (center of projection) at the origin facing towards -z and with the vector up oriented with the y-axis is\n\n![Perspective Projection](perspective-projection.png)\n\n$$\n\\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\n0 & 0 & -\\frac{1}{d} & 0\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nx\\\\\ny\\\\\nz\\\\\n1\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nx\\\\\ny\\\\\nz\\\\\n-\\frac{z}{d}\\\\\n\\end{bmatrix}\n$$\n\nAnd after the division we will have\n\n$$\n\\begin{bmatrix}\n-\\frac{dx}{z}\\\\\n-\\frac{dy}{z}\\\\\n-d\\\\\n\\end{bmatrix}\n$$\n\nThe perspective frustum is\n\n$$\np^{\\prime} \n=\n\\begin{bmatrix}\np_x^{\\prime}\\\\\np_y^{\\prime}\\\\\np_z^{\\prime}\\\\\nw\\\\\n\\end{bmatrix}\n= M_{\\text{perspective projection}}p =\n\\begin{bmatrix}\n\\frac{2n}{r-l} & 0 & \\frac{r+l}{r-l} & 0\\\\\n0 & \\frac{2n}{t-b} & \\frac{t+b}{t-b} & 0\\\\\n0 & 0 & -\\frac{f+n}{f-n} & -\\frac{2nf}{f-n}\\\\\n0 & 0 & -1 & 0\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\np_x\\\\\np_y\\\\\np_z\\\\\n1\\\\\n\\end{bmatrix}\n$$\n\n[Perspective Frustum](https://github.com/vitaminac/minige/blob/2011e5b8c7d833e67ddab40aa28a7e511a2aae5b/src/geometry/mat4.cpp#L143-L156)\n\nGiven the **field of view $\\alpha$** in y direction and the **aspect ratio $\\beta$** of a display screen is equal to the ratio of $x$ (width) to $y$ (height)\n\n$$\ne = \\frac{1}{\\tan{\\frac{\\alpha}{2}}}\n$$\n\nThe view frustum plane normal directions in OpenGL camera space is\n\n![Camera Space](camera-space-opengl.png)\n![Perspective Frustum](perspective-frustum.png)\n\nBecause of the symmetry along x, y axis, the following relationships hold\n\n$$\nt = \\tan{\\frac{\\alpha}{2}} n = \\frac{n}{e}\\\\\nb = -t\\\\\nr = t \\cdot \\beta = \\frac{n\\beta}{e}\\\\\nl = -r\\\\\n\\frac{r+l}{r-l} = \\frac{t+b}{t-b} = 0\\\\\n\\frac{2n}{r-l} = \\frac{e}{\\beta}\\\\\n\\frac{2n}{t-b} = e\\\\\n$$\n\n$$\n\\begin{bmatrix}\n\\frac{e}{\\beta} & 0 & 0 & 0\\\\\n0 & e & 0 & 0\\\\\n0 & 0 & -\\frac{f+n}{f-n} & -\\frac{2nf}{f-n}\\\\\n0 & 0 & -1 & 0\\\\\n\\end{bmatrix}\n$$\n\n[Perspective Projection](https://github.com/vitaminac/minige/blob/6e5ea57ff4bb7c012a528311f9b05dd46a1bd0e0/src/geometry/mat4.cpp#L128-L141)\n\n### Frustum Culling\n\nAfter applying the projection matrix, each vertex is transformed into **homogeneous clip space**, where its position is given in homogeneous coordinates. $(ùë•,ùë¶,ùëß,ùë§)$. In this space, the viewing frustum is defined as a normalized cube called the **canonical view volume** (**CVV**). Any vertex whose **homogeneous clip space** coordinates fall outside these bounds is considered outside the frustum and should be clipped (discarded).\n\n$$\n-ùë§ \\le x \\le ùë§\\\\\n‚àíw \\le y \\le w\\\\\n‚àíw \\le z \\le w\\\\\n$$\n\nOpenGL pipeline automatically performs clipping after vertex processing. If a vertex is within the range, it is passed to next stage. Otherwise, OpenGL may discard it, depending on the rest of the geometry.\n\n## MVP Matrix\n\nWe can chain all three matrices together to a single matrix $M_{\\text{model, view, projection}} = M_{projection} M_{\\text{view}} M_{\\text{model}}$. We can now perform a 4x4 affine transformation with MVP matrix to map an object from **model space** into **homogeneous clip space** $p^{\\prime} = M_{\\text{model, view, projection}} p$.\n\n## 3D Normalized Device Coordinates\n\nGiven a **homogeneous clip space**, now we subsequently divide $x$, $y$, $z$ by the $w$ coordinate of the **homogeneous clip space**, this operation produces **3D normalized device coordinates** (**NDC**), also commonly known as \"**screen space**\".\n\n![NDC](normalized-device-coordinates.png)\n\nThat is a normalized 6-tuple cube which defines the clipping planes. The dimensions are between -1 and 1 for every axis, anything outside the [1, -1] range is outside the camera view area. The cube is translated so that it is centered at the origin which is defined by having a minimum corner (-1,-1,-1) at left-bottom-near and a maximum corner (1,1,1) at right-top-far.\n\n## Viewport Transformation Matrix\n\nThe **NDC** now represent the 2D positions of points on screen, with X and Y in [‚àí1, 1], together with the depth within the depth buffer range, Z in [‚àí1, 1]. The axis orientation is X = right, Y = up, and Z can be either forward or backward depending on the depth buffer configuration.\n\n![Pipeline](transformation-pipeline.PNG)\n\nTo render on the portion of the output device expressed in pixels (**viewport**), we apply the viewport transform to the normalized device coordinates.\n\n![Viewport](viewport.png)\n\n$$\nV = TS = \n\\begin{bmatrix}\n1 & 0 & 0 & \\frac{r+l}{2}\\\\\n0 & 1 & 0 & \\frac{t+b}{2}\\\\\n0 & 0 & 1 & \\frac{1}{2}\\\\\n0 & 0 & 0 & 1\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\frac{r-l}{2} & 0 & 0 & 0\\\\\n0 & \\frac{t-b}{2} & 0 & 0\\\\\n0 & 0 & \\frac{1}{2} & 0\\\\\n0 & 0 & 0 & 1\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\frac{r-l}{2} & 0 & 0 & \\frac{r+l}{2}\\\\\n0 & \\frac{t-b}{2} & 0 & \\frac{t+b}{2}\\\\\n0 & 0 & \\frac{1}{2} & \\frac{1}{2}\\\\\n0 & 0 & 0 & 1\\\\\n\\end{bmatrix}\n$$\n\n## Reference\n\n* [3D Math Primer For Graphics and Game Development](https://www.amazon.com/gp/product/1568817231/ref=dbs_a_def_rwt_bibl_vppi_i0) pag. 138-144, 176-189\n* [Matrices - Sparky Engine](https://www.youtube.com/watch?v=5-minbbZW14&t=56s&list=PLlrATfBNZ98fqE45g3jZA_hLGUrD4bo6_&index=10)\n* [Fundamentals of Computer Graphics](https://www.amazon.com/Fundamentals-Computer-Graphics-Peter-Shirley/dp/1568814690) pag. 140-144\n* [Mathematics for 3D Game Programming and Computer Graphics, Third Edition](https://www.amazon.com/Mathematics-Programming-Computer-Graphics-Third/dp/1435458869) pag. 75, 76, 101-115\n* [Wikipedia - Orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection#Geometry)\n* [World, View and Projection Transformation Matrices](http://www.codinglabs.net/article_world_view_projection_matrix.aspx)\n* [3D Transformation](https://www.tutorialspoint.com/computer_graphics/3d_transformation.htm)\n* [The Perspective and Orthographic Projection Matrix](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix)\n* [The Viewport Transformation](http://glasnost.itcarlow.ie/~powerk/GeneralGraphicsNotes/projection/viewport_transformation.html)\n* [Lean OpenGL - Coordinate Systems](https://learnopengl.com/Getting-started/Coordinate-Systems)",
      "slug": "Matrices-in-Computer-Graphics",
      "date": "2020-05-31 13:34:44",
      "lang": "en",
      "tags": [
        "4D Matrices",
        "Translation Matrix",
        "Projection Matrix",
        "Rotation Matrix",
        "Scaling Matrix",
        "Model Matrix",
        "View Matrix",
        "Projecion Matrix",
        "Matrix",
        "Computer Graphics"
      ],
      "path": "/Matrices-in-Computer-Graphics/index.html"
    },
    "lang": "en",
    "_nextI18Next": {
      "initialI18nStore": {
        "en": {
          "navbar": {
            "Home": "Home",
            "Language": "Language",
            "Tags": "Tags",
            "en": "English",
            "es": "Spanish",
            "zh": "Chinese"
          },
          "post-layout": { "Author": "Author: {{author}}", "Tags": "Tags" }
        }
      },
      "initialLocale": "en",
      "ns": ["navbar", "post-layout"],
      "userConfig": {
        "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] },
        "default": {
          "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] }
        }
      }
    }
  },
  "__N_SSG": true
}
