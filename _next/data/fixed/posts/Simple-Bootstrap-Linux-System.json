{
  "pageProps": {
    "postData": {
      "title": "Build Simple Bootstrap Linux System Image",
      "markdownContentSource": "\n## Kernel Image for Emulation\n\nWe will create a tiny Linux system with absolute minimum additional software. We reuse host kernel image **vmlinuz** to simply the process.\n\n    cp /vmlinuz vmlinuz\n\n**vmlinux** is a [ELF format](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) based Linux kernel executable image and **[vmlinuz](https://s905060.gitbooks.io/site-reliability-engineer-handbook/content/anatomy_of_the_initrd_and_vmlinuz.html) (Virtual Memory Linux gZip)** is a compressed version of **vmlinux**. At the beginning of **vmlinuz** is a routine that does some minimal amount of hardware setup and then decompresses the kernel contained within the kernel image and places it into high memory. The routine then calls the kernel and the kernel boot begins.\n\n## Initramfs\n\nWe need a temporary root file system, an **initramfs** when the kernel boots up. An initramfs is a **cpio** compressed archive. Unlike the [old initrd](https://www.kernel.org/doc/html/latest/filesystems/ramfs-rootfs-initramfs.html?highlight=initramfs#ramfs-and-ramdisk), **initramfs** reuse disk cache mechanism of main memory so **initramfs** doesn't require creating a synthetic block device nor having a intermediate file-system driver inside the kernel to interpret the data which may have license problem and avoid unnecessarily copying memory from the fake block device into the page cache. Bootloader places **initramfs** image(s) in a memory location and then pass its location and its size as [parameter](https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html) to kernel. The kernel checks for the presence of the **initramfs** and if found it is unpacked into a RAM disk at kernel initialization, mounts it as **/**. Once **initramfs** is extracted, into **rootfs** the kernel checks if it contains a file **/init**. If it does, the kernel executes this **/init** file.\n\n    mkdir simple\n    cd simple\n\n### Shell Environment\n\n    sudo apt install busybox-static\n\nWe have to install **[busybox-static](https://packages.debian.org/buster/busybox-static)**, **[busybox](https://packages.debian.org/buster/utils/busybox)** does not install symbolic links for any of the supported utilities.\n\n    mkdir -p bin sbin usr/bin usr/sbin\n    cp /bin/busybox bin/busybox\n    ln -s busybox bin/sh\n\n### Configure Keyboard Layout for Spanish\n\nWe have to [install the list of keymaps](https://stackoverflow.com/a/34882663/9980245)\n\n    sudo apt install kbd console-data\n\n[Convert to binary format](https://bbs.archlinux.org/viewtopic.php?id=191064) and copy to our **initramfs**\n\n    loadkeys -b /usr/share/keymaps/i386/qwerty/es.kmap.gz > es.kmap\n\n### [Support USB Devices](https://www.cyberciti.biz/faq/usb-drive-not-being-recognized-under-linux/)\n\nWe repeatedly use this command [sudo lsmod | grep usb_storage](https://askubuntu.com/a/521231) to recursively find all modules that are required for USB hot-plug. They are the [following modules](https://unix.stackexchange.com/a/299501) in total\n\n* [ohci-hcd](https://www.kernel.org/doc/html/latest/usb/ohci.html)\n* ohci-pci\n* uas\n* usb_storage\n* usbcore\n* scsi_mod\n* usb_common\n* [sd_mod](https://tldp.org/HOWTO/SCSI-2.4-HOWTO/sd.html)\n* fat\n* vfat\n* [nls_* e.g. nls_cp437, nls_ascii](https://unix.stackexchange.com/q/62086)\n\nWe then use **[sudo modinfo [module name]](https://www.cyberciti.biz/faq/linux-how-to-load-a-kernel-module-automatically-at-boot-time/)** to find each module path and copy to our **initramfs**.\n\n    mkdir -p lib/modules/$(uname -r)\n    cp /lib/modules/$(uname -r)/kernel/drivers/usb/host/ohci-hcd.ko lib/modules/$(uname -r)\n    cp /lib/modules/$(uname -r)/kernel/drivers/usb/host/ohci-pci.ko lib/modules/$(uname -r)\n    cp /lib/modules/$(uname -r)/kernel/drivers/usb/storage/uas.ko lib/modules/$(uname -r)\n    cp /lib/modules/$(uname -r)/kernel/drivers/usb/storage/usb-storage.ko lib/modules/$(uname -r)\n    cp /lib/modules/$(uname -r)/kernel/drivers/usb/core/usbcore.ko lib/modules/$(uname -r)\n    cp /lib/modules/$(uname -r)/kernel/drivers/usb/core/usbcore.ko lib/modules/$(uname -r)\n    cp /lib/modules/$(uname -r)/kernel/drivers/scsi/scsi_mod.ko lib/modules/$(uname -r)\n    cp /lib/modules/$(uname -r)/kernel/drivers/usb/common/usb-common.ko lib/modules/$(uname -r)\n    cp /lib/modules/$(uname -r)/kernel/drivers/scsi/sd_mod.ko lib/modules/$(uname -r)\n    cp /lib/modules/$(uname -r)/kernel/fs/fat/vfat.ko lib/modules/$(uname -r)\n    cp /lib/modules/$(uname -r)/kernel/fs/fat/fat.ko lib/modules/$(uname -r)\n    cp /lib/modules/$(uname -r)/kernel/fs/nls/*.ko lib/modules/$(uname -r)\n\n### Init Script\n\nWe will require a **/init** program, it is typically a shell script. It configures some basic device nodes and directories, mounts the special **/sys** and **/proc** file systems, and starts the processing of hotplug events using mdev and then execute the more-typical /sbin/init program.\n\n    nano init\n\nand put following content\n\n    #!/bin/sh\n    # install symlinks for all of the suppoted utilities\n    # install busybox symbolic links\n    /bin/busybox --install -s\n    #\n    [ -d /dev ] || mkdir -m 0755 /dev\n    [ -d /root ] || mkdir --mode=0700 /root\n    [ -d /sys ] || mkdir /sys\n    [ -d /proc ] || mkdir /proc\n    [ -d /tmp ] || mkdir /tmp\n    mkdir -p /var/lock\n    #\n    mount -t sysfs none /sys -onodev,noexec,nosuid\n    mount -t proc none /proc -onodev,noexec,nosuid\n    #\n    mknod /dev/zero c 1 5\n    mknod /dev/null c 1 3\n    mknod /dev/tty c 5 0\n    mknod /dev/console c 5 1\n    mknod /dev/ptmx c 5 2\n    mknod /dev/tty0 c 4 0\n    mknod /dev/tty1 c 4 1\n    # load USB drivers\n    depmod -a # https://stackoverflow.com/q/45658297/9980245\n    modprobe ohci-pci\n    modprobe uas\n    modprobe sd_mod\n    # initial population and dynamic updates\n    echo \"/sbin/mdev\" > /proc/sys/kernel/hotplug\n    /sbin/mdev -s\n    # change keymaps http://ilikelinux69.github.io/How-to-change-the-keyboard-layout-in-Busybox\n    loadkmap < es.kmap\n    # traditional init program\n    exec /sbin/init\n\nadd the execution permission\n\n    chmod a+x init\n\n[compress into cpio images](https://www.kernel.org/doc/html/latest/admin-guide/initrd.html#compressed-cpio-images)\n\n    find . | cpio --quiet -o -H newc | gzip >../simple.igz\n\nThe result **simple.igz** is our **initramfs**.\n\n#### Install Busybox Symbolic Links\n\nThe **busybox** provide a **--install** options to create symbolic links (**-s**) for all the supported commands in **/bin**, **/sbin**, **/usr/sbin**. Here are the list of command that **busybox** install.\n\n* ls -al **/bin** | grep \"\\->\" | less\n  * arch\n  * ash\n  * cat\n  * chgrp\n  * chmod\n  * chown\n  * cp\n  * cpio\n  * cttyhack\n  * date\n  * dd\n  * df\n  * dmesg\n  * dnsdomainname\n  * dumkmap\n  * echo\n  * ed\n  * egrep\n  * false\n  * fatattr\n  * fgrep\n  * getopt\n  * grep\n  * hunzip\n  * gzip\n  * hostname\n  * ionice\n  * ipcalc\n  * kill\n  * link\n  * linux32\n  * linux64\n  * ln\n  * login\n  * ls\n  * lzop\n  * mkdir\n  * mknod\n  * mktemp\n  * more\n  * mount\n  * mt\n  * mv\n  * netstat\n  * nuke\n  * pidof\n  * ping\n  * ping6\n  * ps\n  * pwd\n  * readlink\n  * resume\n  * rev\n  * rm\n  * rmdir\n  * rpm\n  * run-parts\n  * sed\n  * setpriv\n  * sh\n  * sleep\n  * slat\n  * stty\n  * su\n  * sync\n  * tar\n  * touch\n  * true\n  * umount\n  * uname\n  * uncompress\n  * usleep\n  * vi\n  * watch\n  * zcat\n* ls -al **/sbin** | grep \"\\->\" | less\n  * acpid\n  * adjtimex\n  * arp\n  * blockdev\n  * depmod\n  * devmem\n  * fdisk\n  * freeramdisk\n  * fstrim\n  * getty\n  * halt\n  * hwclock\n  * ifconfig\n  * ifdown\n  * ifup\n  * init\n  * insmod\n  * ip\n  * ipneigh\n  * klogd\n  * loadkmap\n  * logread\n  * losetup\n  * lsmod\n  * mdev\n  * mkdosfs\n  * mke2fs\n  * mkswap\n  * modinfo\n  * modprobe\n  * nameif\n  * pivot_root\n  * poweroff\n  * reboot\n  * rmmod\n  * route\n  * run-init\n  * start-stop-daemon\n  * sulogin\n  * swapon\n  * switch_root\n  * sysctl\n  * syslogd\n  * tc\n  * tunctl\n  * udhcpc\n  * uevent\n  * vconfig\n  * watchdog\n* ls -al **/usr/bin** | grep \"\\->\" | less\n  * [\n  * [[\n  * ar\n  * awk\n  * basename\n  * bc\n  * blkdiscard\n  * bunzip2\n  * bzcat\n  * bzip2\n  * cal\n  * chvt\n  * clear\n  * cmp\n  * crontab\n  * cut\n  * dc\n  * deallocvt\n  * diff\n  * dirname\n  * dos2unix\n  * dkpg\n  * dkpg-deb\n  * du\n  * dumpleases\n  * env\n  * expand\n  * expr\n  * factor\n  * fallocate\n  * find\n  * fold\n  * free\n  * ftpget\n  * ftpput\n  * groups\n  * head\n  * hexdump\n  * hostid\n  * id\n  * killall\n  * last\n  * less\n  * loggger\n  * logname\n  * lsscsi\n  * lzcat\n  * lzma\n  * md5sum\n  * microcom\n  * mkfifo\n  * mkpasswd\n  * nc\n  * nl\n  * nproc\n  * nsenter\n  * nslookup\n  * od\n  * openvt\n  * passwd\n  * paste\n  * patch\n  * printf\n  * realpath\n  * renice\n  * reset\n  * rpm2cpio\n  * seq\n  * setkeycodes\n  * setsid\n  * sha1sum\n  * sha256sum\n  * sha512sum\n  * shred\n  * shuf\n  * sort\n  * ssl_client\n  * strings\n  * svc\n  * svok\n  * tac\n  * tail\n  * taskset\n  * tee\n  * telnet\n  * test\n  * tftp\n  * time\n  * timeout\n  * top\n  * tr\n  * traceroute\n  * traceroute6\n  * truncate\n  * tty\n  * unexpand\n  * uniq\n  * unix2dos\n  * unlink\n  * unlzma\n  * unshare\n  * unxz\n  * unzip\n  * uptime\n  * uudecode\n  * uuencode\n  * w\n  * wc\n  * wget\n  * which\n  * who\n  * whoami\n  * xargs\n  * xxd\n  * xz\n  * xzcat\n  * yes\n\n#### [Initial Population and Dynamic Updates](https://git.busybox.net/busybox/plain/docs/mdev.txt)\n\nWe instruct the kernel to execute /sbin/mdev whenever a device is added or removed so that the device node can be created or destroyed. Then we seed /dev with all the device nodes that were created while the system was booting.\n\n#### Traditional Init Program\n\nAt the end of **/init** we call **/sbin/init** program which coordinates the rest of the boot process and configures the enviroment for the user. It becomes the parent or grandparent of all the processes that start up automatically on the system. In our case **/sbin/init** is our **busybox** console. At this point we have two busybox running one executing the /init and second one - our console **/sbin/init** that is executed by **/init**.\n\n## Test the Constructed Image\n\n    cd ..\n\n### Run with QEMU Emulator\n\nInstall the QEMU\n\n    sudo apt install qemu-system\n\nExecute the kernel with host architecture e.g. x86_64.\n\n    qemu-system-x86_64 -vnc :0 -kernel vmlinuz -initrd simple.igz -append \"root=/dev/ram\" /dev/zero\n\n### Booting a real machine\n\nThe **syslinux** package allows us to construct bootable systems for standard PCs on DOS-formatted storage.\n\n    sudo apt install syslinux\n\nA suitable medium should be chosen to boot from, e.g., a DOS-formatted USB flash drive. The DOS partition of the USB flash drive must be marked bootable. Some USB flash drives might need repartitioning and reformatting with the Linux tools in order to work correctly.\n\n#### [Syslinux Boot Process Overview](https://wiki.archlinux.org/index.php/syslinux#Boot_process_overview)\n\n1. **Stage 1 - Part 1 - Load [MBR](https://en.wikipedia.org/wiki/Master_boot_record#Sector_layout)**: At boot, the BIOS loads the 440 byte [MBR boot code](https://git.kernel.org/pub/scm/boot/syslinux/syslinux.git/tree/mbr/mbr.S?id=4298786ca19e9121568ecd4cc8b79d276ccfd24a) at the start of the disk (**/usr/lib/syslinux/bios/mbr.bin**).\n2. **Stage 1 - Part 2 - [Search active partition](https://git.kernel.org/pub/scm/boot/syslinux/syslinux.git/tree/mbr/mbr.S?id=4298786ca19e9121568ecd4cc8b79d276ccfd24a#n195)**: The MBR boot code looks for the active partition that is marked with boot flag. e.g. **/boot** partition.\n3. **Stage 2 - Part 1 - Execute volume boot record:**  The [MBR boot code executes the Volume Boot Record (VBR) of the /boot partition](https://git.kernel.org/pub/scm/boot/syslinux/syslinux.git/tree/core/diskstart.inc?id=10f6cf6eef0a7da7dad1933efdbfb101155792d0#n154). In the case of Syslinux, the VBR boot code is the starting sector of /boot/syslinux/ldlinux.sys which is created by the extlinux --install command.\n4. **Stage 2 - Part 2 - Execute /boot/syslinux/ldlinux.sys:** - The VBR will [load the rest of /boot/syslinux/ldlinux.sys](https://git.kernel.org/pub/scm/boot/syslinux/syslinux.git/tree/core/diskstart.inc#n154). The sector location of /boot/syslinux/ldlinux.sys should not change, otherwise syslinux will not boot.\n5. **Stage 3 - Load /boot/syslinux/ldlinux.c32:** The /boot/syslinux/ldlinux.sys will load the /boot/syslinux/ldlinux.c32 (core module) that contains the rest of the core part of syslinux that could not be fit into ldlinux.sys (due to file-size constraints). The ldlinux.c32 file should be present in every Syslinux installation and should match the version of ldlinux.sys installed in the partition.\n6. **Stage 4 - Search and Load configuration file:** - Once Syslinux is fully loaded, it [looks for /boot/syslinux/syslinux.cfg and loads](https://git.kernel.org/pub/scm/boot/syslinux/syslinux.git/tree/core/fs/lib/loadconfig.c?id=7d9c9eca562857fed25b4c8ef902e3de968d7631).\n\n#### Config for syslinux\n\nThe syslinux program should be run on the device something similar to /dev/sdx1 for a USB flash drive. You should be careful, as selecting the wrong devide name might overwrite your host system's hard drive. The syslinux loader can be \nconfigured using a file called **syslinux.cfg** \n\n    nano syslinux.cfg\n\nwhich would look something like:\n\n    Default simple\n    timeout 100\n    prompt 1\n    label simple\n      kernel vmlinuz\n      append initrd=simple.igz root=/dev/ram\n\n#### Burning the Bootloader\n\nWe give our user permission that allow **syslinux** to write code to MBR. We add our username to [disk](https://wiki.debian.org/SystemGroups#Groups_without_an_associated_user) group which have **raw access to disks** with [usermod](https://man7.org/linux/man-pages/man8/usermod.8.html).\n\n    sudo usermod -G disk -a $(whoami)\n\nWe execute this command only once, the change is permanent. We now mount the USB devices and copy the remaining archives to normal file system, we can use **dmesg** to find **sdX1**.\n\n    sudo syslinux /dev/sdX1\n    # Mount hand if not magicaly mounted when connected.\n    sudo mkdir /mnt/test\n    sudo mount -t vfat /dev/sdX1 /mnt/test\n    # And then work with /mnt/test\n    sudo cp vmlinuz simple.igz syslinux.cfg /mnt/test\n    sudo umount /mnt/test\n\nThe device may now be removed and booted on an appropriate PC.\n\n#### Test with VirtualBox\n\n1. Download [Plop Boot Manager](https://www.plop.at/en/bootmanager/download.html)\n2. Extract plpbt.iso\n3. From Settings -> Sorage -> Controller: IDE -> Add -> Select plpbt.iso\n4. From Settings -> System -> Boot Order -> Ensure Optical is before any other devices\n5. From Plop boot menu select USB device\n\nWhen we finish booting from USB, we can unplug USB. All content, kernel and initramfs is available in the main memory, we don't use USB anymore. We could not access the content of our USB since there is no corresponding driver for USB and file system.\n\n#### [Mount USB](https://unix.stackexchange.com/a/134516)\n\nSince there is no **[udev](https://wiki.debian.org/udev)** running, we have to create block device node in **/dev** manually. First check with **dmesg** if drivers detect USB and which identifier it has e.g. sda1 and then create our block device manually which following parameters for sda1, if identifier is diferrent you have to check [here](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/admin-guide/devices.txt?id=15ab85695595fbaba1ccccd07f7b0cede57cccf2#n200).\n\n    mknod /dev/sda b 8 0\n    mknod /dev/sda1 b 8 1\n    mkdir -p /mnt/test\n    mount -t vfat /dev/sda1 /mnt/test\n\n## Reference\n\n* [Un Sistema Linux Empotrado Sencillo](http://www.datsi.fi.upm.es/docencia/SEUM/publico/practica_USLES.pdf)\n* [An introduction to the Linux boot and startup processes](https://opensource.com/article/17/2/linux-boot-and-startup)\n* [A DETAILED LOOK AT THE BOOT PROCESS](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/installation_guide/s1-boot-init-shutdown-process)\n* [Disk Group](https://wiki.debian.org/SystemGroups#Groups_without_an_associated_user)\n* [Anatomy of the initrd and vmlinuz](https://s905060.gitbooks.io/site-reliability-engineer-handbook/content/anatomy_of_the_initrd_and_vmlinuz.html)\n* [Ramfs, rootfs and initramfs](https://www.kernel.org/doc/html/latest/filesystems/ramfs-rootfs-initramfs.html?highlight=initramfs#ramfs-and-ramdisk)\n* [Package: busybox](https://packages.debian.org/buster/utils/busybox)\n* [QEMU Example: Deploying initramfs](https://docs.windriver.com/bundle/Wind_River_Linux_Users_Guide_3.0_1/page/497722.html)",
      "slug": "Simple-Bootstrap-Linux-System",
      "date": "2020-11-08 19:15:57",
      "lang": "en",
      "tags": ["Linux", "Embedded System"],
      "path": "/Simple-Bootstrap-Linux-System/index.html"
    },
    "lang": "en",
    "_nextI18Next": {
      "initialI18nStore": {
        "en": {
          "common": { "Next": "Next" },
          "feature-tags": { "Tags": "Tags" },
          "navbar": {
            "Home": "Home",
            "Language": "Language",
            "Tags": "Tags",
            "en": "English",
            "es": "Spanish",
            "zh": "Chinese"
          },
          "post-layout": { "Author": "Author: {{author}}" }
        }
      },
      "initialLocale": "en",
      "ns": ["common", "feature-tags", "navbar", "post-layout"],
      "userConfig": {
        "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] },
        "default": {
          "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] }
        }
      }
    }
  },
  "__N_SSG": true
}
