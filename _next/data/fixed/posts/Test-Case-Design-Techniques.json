{
  "pageProps": {
    "postData": {
      "title": "Test Case Design Techniques",
      "markdownContentSource": "\n| Approach/Implementation | White Box                 | Black Box         |   |   |\n|-------------------------|---------------------------|-------------------|---|---|\n| Structural              | Control-flow<br>Data-flow |                   |   |   |\n| Fault-based             | Mutation                  |                   |   |   |\n| Error-based             |                           | Functional Random |   |   |\n\n## Control-flow Techniques\n\n* Generate test cases taking into account the program control structure.\n* Based on the concept of **coverage**.\n  * Statement coverage\n  * Branch coverage\n  * Condition coverage\n  * Desision/condition coverage\n  * Multiple condition coverage\n\n### Example\n\n    IF (A OR B) THEN\n        print C\n\n### Statement Coverage\n\nRequire each statement in the program been executed.\n\n* (A OR B) = TRUE\n\ne.g.\n\n1. T1: A=TRUE, B=FALSE\n\n### Branch Coverage\n\nRequire each breanch of each control structure been executed.\n\n* (A OR B) = TRUE\n* (A OR B) = FALSE\n\ne.g.\n\n1. T1: A=TRUE, B=FALSE\n2. T2: A=FALSE, B=FALSE\n\n### Conditiona Coverage\n\nRequire each boolean sub-expression evaluated both to true and false.\n\n* A = TRUE\n* A = FALSE\n* B = TRUE\n* B = FALSE\n\ne.g.\n\n1. T1: A=TRUE, B=FALSE\n2. T2: A=FALSE, B=TRUE\n\n### Decision/Condition Coverage\n\nRequires that both decision and condition coverage been satisfied.\n\n* A = TRUE\n* A = FALSE\n* B = TRUE\n* B = FALSE\n* (A OR B) = TRUE\n* (A OR B) = FAKSE\n\ne.g.\n\n1. T1: A=TRUE, B=FALSE\n2. T2: A=FALSE, B=TRUE\n3. T3: A=FALSE, B=FALSE\n\n### Multiple Condition Coverage\n\nRequire all the combinations of boolean sub-expressions should be evaluated\n\n1. A=TRUE, B=FALSE\n2. A=FALSE, B=TRUE\n3. A=FALSE, B=FALSE\n4. A=TRUE,B=TRUE\n\n### Basic Path Testing\n\nAnalyze the sequences of statements from the program input to output - **paths** of a program and drwa the control flow graph.\n\n#### Flowchart\n\n* Nodes: represent zero, one or more statements.\n* Edges: link two nodes\n* Regions: areas delimited by edges and nodes\n* Predicate nodes: bifurcation node\n\n![Flowchart](flowchart.png)\n\n#### Cyclomatic Complexity\n\n* C(G) represents complexity\n  * C(G) = Number of regions\n  * C(G) = Edges - Nodes + 2\n  * C(G) = Number of predicate nodes + 1\n\n#### Determine Basic Set of Independent Paths - Equivalent to Decision/Consition Coverage\n\n![Example](example-independent-paths.png)\n\n1. 1 - 2 - 4 - 5 - 8 - 10\n2. 1 - 2 - 3 - 2 - 4 - 5 - 8 - 10\n3. 1 - 2 - 4 - 6 - 8 - 10\n4. 1 - 2 - 4 - 6 - 7 - 8 - 10\n5. 1 - 2 - 4 - 5 - 8 - 9 - 10\n6. 1 - 2 - 4 - 5 - 8 - 9 - 2 - 4 - 5 - 8 - 10\n\n#### Modern Practice\n\n* Check coverage using modern IDE\n\n## Functional Techniques\n\n* Program is viewed as a black box\n* They try to run test cases related to possible program faults\n\n### Equivalence Partitioning\n\n* Divides the program input domain into data classes used to derive test cases.\n* An equivalence class represents a set of valid or invalid states for program input conditions.\n* Each input condition is examined and divided into two or more groups, identifying two types of classes\n* An input condition typically refers to the set of values a given input can take\n* Two types of equivalence classes are defined:\n  * Valid equivalence classes: Represent valid program inputs.\n  * Invalid equivalence classes: Represent incorrect input values.\n\n![Equivalence Partitioning](equivalence-partitioning.png)\n\n#### Value Range\n\n* One valid and two invalid classes (above, below)\n* E.g.: counter range is from 1 to 999\n  * Valid class: 1 <= counter <= 999\n  * Invalid class: counter < 1\n  * Invalid class: a counter > 999\n\n#### Number of Values\n\n* One valid and two invalid classes\n* E.g.: a car can have from one to six owners in its lifetime\n  * Valid class: “from one to six owners”\n  * Invalid class: “there are no owners”\n  * Invalid class: “over six owners\n\n#### Logical/Boolean Situation\n\n* One of each type\n* Sometimes a logical condition cannot be reduced to yes/no\n* E.g: the first character of the identifier should be a letter\n  * Valid class: “identifier starting with letter” \n  * Invalid class: identifier not starting with letter\n    * starting with a number\n    * starting with a symbol\n\n##### Set of input values\n\n* If there are reasons to believe that the program will treat each group member differently, identify a valid class for each member, and an invalid class\n  * E.g. vehicle type is: bus, truck, car or motorbike\n    * 4 Valid classes: “bus”, “truck”, “car”, “motorbike”\n    * Invalid class: any other vehicle type, e.g., “cycle”, “mobile house”\n\n##### Other\n\n* Generally, if there is any reason for believing that the program does not treat the items of an equivalence class equally\nE.g.: some phone prefixes are not admitted\n* Divide the equivalence class into smaller equivalence classes for each item type\n\n#### Equivalence Partitioning's Example\n\nBanking application, where the user can perform some bank transactions. The information for accessing the transactions requires the following input:\n\n##### Bank Code\n\nBlank or three-digit number. The first digit of the three-digit number should be greater than 1.\n\n* Valid Equivalence Class\n  * Blank\n  * 3-digit number ranged from 200 <= Bank code <= 999\n\n##### Branch Code\n\nA four-digit number, the first of which is greater than 0.\n\n* Valid Equivalence Class\n  * 4-digit number, 1000 <= Branch code <=9999 \n* Invalid Equivalence Class\n  * Non-numerical value\n  * Number of more than 4 digits\n  * Number of less than 4 digits\n  * 4-digit number, Branch code < 1000\n\n##### Account Number\n\nFive-digit number.\n\n* Valid Equivalence Class\n  * Any five-digit number\n* Invalid Equivalence Class\n  * Non-numerical value\n  * Number of more than five digits\n  * Number of less than five digits\n\n##### Password\n\nFive-position alphanumerical value.\n\n* Valid Equivalence Class\n  * Any five-position alphanumerical character string\n* Invalid Equivalence Class\n  * Non-alphanumerical character string\n  * String of less than five positions\n  * String of more than five positions\n\n##### Order\n\nEither blank or one of the following two strings: “Checkbook” or “Transactions”\n\n* Valid Equivalence Class\n  * \"Checkbook\"\n  * \"Transactions\"\n* Invalid Equivalence Class\n  * Any string that is not the empty or the same as the valid strings\n\n##### Generate Test Cases\n\n* Write a case to cover as many uncovered valid classes as possible until the test cases cover all the valid equivalence classes\n* Write a case to cover just one uncovered invalid classes until the test cases cover all the invalid equivalence classes\n\n### Boundary Value Analysis\n\n* Instead of selecting just any test case in the valid and invalid classes, you test the edges between equivalence partitions\n* Instead of focusing just on the input domain, it designs the test cases also taking into account the output domain\n\n![Boundary Value Analysis](boundary-value-analysis.png)\n\n#### Value Range\n\nDesign test cases for the two bounds of the range, and another two cases for situations just above and just below these bounds\n\n#### Number of Values\n\nDesign two test cases for the minimum and maximum values, as well as another two test cases for values just above the maximum and just below the minimum\n\n#### Order Set\n\nPay attention to the first and last elements of the set.\n\n#### Output\n\nApply the above rules to output data as well\n\n## Blackbox Testing Technique\n\n### Decision Table Technique\n\n* Decision table technique is widely used for black box testing. \n* This is a systematic approach where various input combinations and their respective system behavior are captured in a tabular form. \n* Decision table technique is appropriate for the functions that have a logical relationship between two and more than two inputs.\n\n| <!-- -->                        | <!-- -->          | <!-- -->          | <!-- -->          | <!-- -->          | <!-- -->          | <!-- -->          |\n|---------------------------------|-------------------|-------------------|-------------------|-------------------|-------------------|-------------------|\n| Input 1 (Tow Possible Values)   | Possible Value 1  | Possible Value 2  | Possible Value 1  | Possible Value 2  | Possible Value 1  | Possible Value 2  |\n| Input 2 (Three Possible Values) | Possible Value 1  | Possible Value 1  | Possible Value 2  | Possible Value 2  | Possible Value 3  | Possible Value 3  |\n| Expected Result                 | Expected Result 1 | Expected Result 2 | Expected Result 3 | Expected Result 4 | Expected Result 5 | Expected Result 6 |\n\n### State Transition Technique\n\n* State transition testing is used where some aspect of the system can be described in what is called a 'finite state machine'.\n* This method tests whether the function is following state transition specifications on entering different inputs.\n* Any system where you get a different output for the same input, depending on what has happened before, is a finite state system.\n* We usually use **state diagram** to represent such system.\n* The transitions from one state to another are determined by the rules of the 'machine'.\n\n#### Transition Model\n\n* the states that the software may occupy\n* the transitions from one state to another\n* the events that cause a transition\n* the actions that result from a transition\n\n#### PIN Example\n\n![PIN Transition Diagram](pin-example-transition-diagram.png)\n![PIN Transition Table](pin-example-transition-table.png)\n\n#### Web Login Example\n\n| State | Login                  | Validation | Next State |\n|-------|------------------------|------------|------------|\n| S1    | First Attempt          | Invalid    | S2         |\n| S2    | Second Attempt         | Invalid    | S3         |\n| S3    | Third Attempt          | Valid      | S4         |\n| S4    | Redirect to Home page  |            |            |\n| S5    | Redirect to Error Page |            |            |\n\n| State | Login                  | Validation | Next State |\n|-------|------------------------|------------|------------|\n| S1    | First Attempt          | Invalid    | S2         |\n| S2    | Second Attempt         | Invalid    | S3         |\n| S3    | Third Attempt          | Invalid    | S5         |\n| S4    | Redirect to Home page  |            |            |\n| S5    | Redirect to Error Page |            |            |\n\n## Test Case Specification\n\n### Test goal\n\nHigh level description of the purpose of the test case.\n\n### Inputs\n\nActual inputs given to the program.\n\n### Expected outputs\n\nDescription of the program output according to the specification.\n\n### Observed outputs\n\nDescription of the program output when it is run\n\n## Failure Identification\n\nFailures are identified by comparing expected outputs against observed outputs.",
      "slug": "Test-Case-Design-Techniques",
      "date": "2020-11-24 12:56:14",
      "lang": "en",
      "tags": [
        "Test Design",
        "Boundary Value Analysis",
        "Equivalence Partitioning"
      ],
      "path": "/Test-Case-Design-Techniques/index.html"
    },
    "lang": "en",
    "_nextI18Next": {
      "initialI18nStore": {
        "en": {
          "common": { "Next": "Next" },
          "feature-tags": { "Tags": "Tags" },
          "navbar": {
            "Home": "Home",
            "Language": "Language",
            "Tags": "Tags",
            "en": "English",
            "es": "Spanish",
            "zh": "Chinese"
          },
          "post-layout": { "Author": "Author: {{author}}" }
        }
      },
      "initialLocale": "en",
      "ns": ["common", "feature-tags", "navbar", "post-layout"],
      "userConfig": {
        "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] },
        "default": {
          "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] }
        }
      }
    }
  },
  "__N_SSG": true
}
