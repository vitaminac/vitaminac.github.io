{
  "pageProps": {
    "postData": {
      "slug": "SOLID",
      "tags": [
        "SOLID",
        "Object Oriented Programming",
        "Object Oriented Design",
        "Agile Software Development",
        "Software Evolution"
      ],
      "isDraft": false,
      "isArchived": false,
      "title": "SOLID Design Principles",
      "date": "2021-01-10 17:14:33",
      "isLegacy": false,
      "lang": "en",
      "tocHtml": "<ol>\n<li><a href=\"#Single-Responsibility-Principle\">Single Responsibility Principle</a></li>\n<li><a href=\"#OpenClosed-Principle\">Open–Closed Principle</a></li>\n<li><a href=\"#Liskov-Substitution-Principle\">Liskov Substitution Principle</a></li>\n<li><a href=\"#Interface-Segregation-Principle\">Interface Segregation Principle</a></li>\n<li><a href=\"#Dependency-inversion-principle\">Dependency inversion principle</a></li>\n<li><a href=\"#Reference\">Reference</a></li>\n</ol>",
      "articleHtml": "<p>In object-oriented computer programming, SOLID is acronym and stands for a set of five design principles documented by Robert C. Martin. Keep your code in line with SOLID make software designs more clear, and you&#x27;re much more likely to end up with a modular flexible and maintainable. SOLID also mesh well with testability.</p>\n<h2 id=\"Single-Responsibility-Principle\">Single Responsibility Principle<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#Single-Responsibility-Principle\"><i class=\"fa-solid fa-link\"></i></a></h2>\n<p>It states that there should never be more than one\nreason for a class to change. Every module, class, or function should have responsibility over a single part of the functionality provided by the software, and will have only one reason for modification. Writing test for code that follows the SRP is essentially expressing our understanding of the problem and specifying the expected behavior. We can test the class independently. When we add some more functionality, the old tests shouldn&#x27;t fail.</p>\n<h2 id=\"OpenClosed-Principle\">Open–Closed Principle<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#OpenClosed-Principle\"><i class=\"fa-solid fa-link\"></i></a></h2>\n<p>The open/closed principle states software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. This can be achieved by abstraction, polymorphism and several design patterns e.g. strategy, composite, decorator, factory method. Classes that delegate specific responsibilities to other objects allow tests to substitute a test double when needed to simulate a specific scenario.</p>\n<p><img alt=\"Strategy Pattern\" loading=\"lazy\" width=\"720\" height=\"268\" decoding=\"async\" data-nimg=\"1\" style=\"color:transparent\" src=\"/_next/static/media/strategy.3511deb0.png\"/></p>\n<h2 id=\"Liskov-Substitution-Principle\">Liskov Substitution Principle<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#Liskov-Substitution-Principle\"><i class=\"fa-solid fa-link\"></i></a></h2>\n<p>It states that if S is a subtype of T, then objects of type T may be replaced with objects of type S without altering any of the desirable properties of the program. LSP emphasize the hierarchies should exist for the right reason, embodying a valid abstraction. Class hierarchies that follow the LSP enable the use of contract tests, tests written for parent class/interface can be executed against all derived/implementation.</p>\n<p><img alt=\"Liskov Substitution\" loading=\"lazy\" width=\"1264\" height=\"807\" decoding=\"async\" data-nimg=\"1\" style=\"color:transparent\" src=\"/_next/static/media/liskov-substitution.a500a95d.png\"/></p>\n<h2 id=\"Interface-Segregation-Principle\">Interface Segregation Principle<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#Interface-Segregation-Principle\"><i class=\"fa-solid fa-link\"></i></a></h2>\n<p>It states that no client should be forced to depend on methods it does not use, we should split interfaces that are very large into smaller and more specific ones so that clients will only have to know about the methods that are of interest to them. Small interfaces keep test simple for each interface, it also improve testability by making it easier to write and use test doubles.</p>\n<h2 id=\"Dependency-inversion-principle\">Dependency inversion principle<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#Dependency-inversion-principle\"><i class=\"fa-solid fa-link\"></i></a></h2>\n<p>The dependency inversion principle says code should depend on abstractions not on concretions, it suggests that a class shouldn&#x27;t instantiate its own collaborators but rather have their interfaces passed in. The dependency inversion principle is a specific form of decoupling software modules. When following this principle, the conventional dependency relationships from high-level module to low-level module are reversed, thus rendering high-level modules independent of the low-level module implementation details. The principle states:</p>\n<ol>\n<li>High-level modules should not depend on low-level modules. Both should depend on abstractions(interfaces).</li>\n<li>Abstractions should not depend on details. Details (classes) should depend on abstractions.</li>\n</ol>\n<p>The both high-level and low-level objects must depend on the same abstraction. The interaction between a high level module and a low-level one, the interaction should be thought of as an abstract interaction between them.</p>\n<p>The high-level class defines its own adapter interface which is the abstraction that the other high-level classes depend on. The adaptee implementation also depends on the adapter interface abstraction while it can be implemented by using code from within its own low-level module. The high-level has no dependency on the low-level module since it only uses the low-level indirectly through the adapter interface by invoking polymorphic methods to the interface which are implemented by the adaptee and its low-level module, for example <strong>plugin</strong>.</p>\n<p>For writing tests. the ability to pass collaborators in make possible the injection of test double fairly easy.</p>\n<h2 id=\"Reference\">Reference<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#Reference\"><i class=\"fa-solid fa-link\"></i></a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/SOLID\" rel=\"nofollow\" target=\"_blank\">Wikipedia - SOLID</a></li>\n</ul>"
    },
    "lang": "en",
    "_nextI18Next": {
      "initialI18nStore": {
        "en": {
          "navbar": {
            "Home": "Home",
            "Language": "Language",
            "Tags": "Tags",
            "en": "English",
            "es": "Spanish",
            "zh": "Chinese"
          },
          "post-layout": { "Author": "Author: {{author}}", "Tags": "Tags" }
        }
      },
      "initialLocale": "en",
      "ns": ["navbar", "post-layout"],
      "userConfig": {
        "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] },
        "default": {
          "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] }
        }
      }
    }
  },
  "__N_SSG": true
}
