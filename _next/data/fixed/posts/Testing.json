{
  "pageProps": {
    "postData": {
      "slug": "Testing",
      "tags": [
        "Integration Test",
        "Contract Test",
        "End-to-End Test",
        "Unit Test",
        "Load Test",
        "Snapshot Test"
      ],
      "isDraft": false,
      "isArchived": false,
      "title": "Testing",
      "date": "2021-04-24 11:27:04",
      "isLegacy": false,
      "lang": "en",
      "tocHtml": "<ol>\n<li><a href=\"#Unit-Test\">Unit Test</a></li>\n<li><a href=\"#Integration-Test\">Integration Test</a></li>\n<li><a href=\"#Contract-Test\">Contract Test</a></li>\n<li><a href=\"#End-to-End-Test\">End-to-End Test</a></li>\n<li><a href=\"#Load-Test\">Load Test</a></li>\n<li><a href=\"#Snapshot-Test\">Snapshot Test</a></li>\n<li><a href=\"#Reference\">Reference</a></li>\n</ol>",
      "articleHtml": "<h1 id=\"Unit-Test\">Unit Test<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#Unit-Test\"><i class=\"fa-solid fa-link\"></i></a></h1>\n<p>The purpose of unit test is to validate that each unit of the software code performs as expected. A unit may be an individual function, method, procedure, module, or object. Unit testing is done during the development of an application by the developers. If proper unit testing is done in early development, then it saves time and money in the maintenance phase.</p>\n<p><img alt=\"Unit Test\" loading=\"lazy\" width=\"553\" height=\"495\" decoding=\"async\" data-nimg=\"1\" style=\"color:transparent\" src=\"/_next/static/media/unit-testing.d88f9a59.png\"/></p>\n<h1 id=\"Integration-Test\">Integration Test<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#Integration-Test\"><i class=\"fa-solid fa-link\"></i></a></h1>\n<p>Integration tests determine if independently developed units of software work correctly when they are connected to each other. It was performed by activating many modules and running higher level tests against all of them to ensure they operated together.</p>\n<p><img alt=\"Integration Test\" loading=\"lazy\" width=\"1111\" height=\"555\" decoding=\"async\" data-nimg=\"1\" style=\"color:transparent\" src=\"/_next/static/media/integration-test.58302089.png\"/></p>\n<h1 id=\"Contract-Test\">Contract Test<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#Contract-Test\"><i class=\"fa-solid fa-link\"></i></a></h1>\n<p>One of the most common cases of using a test double is when you are communicating with an external service. Typically, such services are being maintained by a different team, they may be subject to slow, and unreliable networks, and maybe unreliable themselves. The test double is indeed not an accurate representation of the external service, e.g. what happens if the external service changes its contract?</p>\n<p><img alt=\"Contract Test\" loading=\"lazy\" width=\"478\" height=\"263\" decoding=\"async\" data-nimg=\"1\" style=\"color:transparent\" src=\"/_next/static/media/contract-test.94e48969.png\"/></p>\n<p>A contract change may break a production application, triggering an emergency fix and an urgent conversation with the supplier team. A good way to deal with this is to continue to run your own tests against the double, but in addition to periodically run a separate set of contract tests. These check that all the calls against your test doubles return the same results as a call to the external service would. A failure in any of these contract tests implies you need to update your test doubles, and probably your code to take into account the service contract change.</p>\n<h1 id=\"End-to-End-Test\">End-to-End Test<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#End-to-End-Test\"><i class=\"fa-solid fa-link\"></i></a></h1>\n<p>E2E tests are smoke test with a very limited range of paths tested that validates entire software from starting to the end along with its integration with external services.</p>\n<h1 id=\"Load-Test\">Load Test<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#Load-Test\"><i class=\"fa-solid fa-link\"></i></a></h1>\n<p>Load Test is a non-functional software test in which the performance of software application is tested under a specific expected load. It determines how the software application behaves while being accessed by multiple users simultaneously. The goal of Load Testing is to improve performance bottlenecks and to ensure stability and smooth functioning of software application before deployment.</p>\n<h1 id=\"Snapshot-Test\">Snapshot Test<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#Snapshot-Test\"><i class=\"fa-solid fa-link\"></i></a></h1>\n<p>Snapshot tests ensure your serializable output (e.g. React tree) does not change unexpectedly. On test runs, we will compare the output with the previous snapshot, the test will fail if they do not match: either the change is unexpected, or the snapshot needs to be updated because of the new version of the code.</p>\n<p>Snapshots identify unexpected interface changes within your application â€“ whether that interface is an API response, UI, logs, or error messages.</p>\n<ul>\n<li>False positive/false negative result in CI: The snapshot should be committed alongside code changes, so CI will run the test with update to date snapshots, and it should be reviewed as part of your code review process. It can also provide a lot of additional context during code review in which reviewers can study your changes better.</li>\n<li>Snapshots take a lot of time to review: We should ensure our snapshots are readable by keeping them focused, short.</li>\n<li>Snapshot tests fail unexpectedly: Tests should be deterministic, running the same tests multiple times on a component that has not changed should produce the same results every time.</li>\n<li>Meaning of each snapshot: Give descriptive names for each snapshot. This makes it easier for reviewers to verify the snapshots during the code review.</li>\n<li>Lot of unit tests: The aim of snapshot testing is not to replace existing unit tests, but in some scenarios, snapshot testing can potentially remove the need for unit testing for a particular set of functionalities (e.g. rendering of React components).</li>\n</ul>\n<h1 id=\"Reference\">Reference<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#Reference\"><i class=\"fa-solid fa-link\"></i></a></h1>\n<ul>\n<li><a href=\"https://martinfowler.com/bliki/IntegrationTest.html\" rel=\"nofollow\" target=\"_blank\">IntegrationTest</a></li>\n<li><a href=\"https://martinfowler.com/bliki/ContractTest.html\" rel=\"nofollow\" target=\"_blank\">ContractTest</a></li>\n<li><a href=\"https://www.guru99.com/unit-testing-guide.html\" rel=\"nofollow\" target=\"_blank\">Unit Testing Tutorial: What is, Types, Tools &amp; Test EXAMPLE</a></li>\n<li><a href=\"https://www.guru99.com/end-to-end-testing.html\" rel=\"nofollow\" target=\"_blank\">END-To-END Testing Tutorial: What is E2E Testing with Example</a></li>\n<li><a href=\"https://www.guru99.com/load-testing-tutorial.html\" rel=\"nofollow\" target=\"_blank\">Load Testing Tutorial: What is? How to? (with Examples)</a></li>\n<li><a href=\"https://jestjs.io/docs/snapshot-testing\" rel=\"nofollow\" target=\"_blank\">Snapshot Testing</a></li>\n</ul>"
    },
    "lang": "en",
    "_nextI18Next": {
      "initialI18nStore": {
        "en": {
          "navbar": {
            "Home": "Home",
            "Language": "Language",
            "Tags": "Tags",
            "en": "English",
            "es": "Spanish",
            "zh": "Chinese"
          },
          "post-layout": { "Author": "Author: {{author}}", "Tags": "Tags" }
        }
      },
      "initialLocale": "en",
      "ns": ["navbar", "post-layout"],
      "userConfig": {
        "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] },
        "default": {
          "i18n": { "defaultLocale": "en", "locales": ["en", "es", "zh"] }
        }
      }
    }
  },
  "__N_SSG": true
}
