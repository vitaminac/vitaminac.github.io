<!doctype html>
<html lang="en">
  <!-- Head tag -->
  <!-- SEO -->

  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Cracking Simpler Cipher｜Gao&#39;s Blog</title>
    <meta
      property="og:title"
      content="Cracking Simpler Cipher｜Gao&#39;s Blog"
    />

    <meta
      name="description"
      content="Cracking Simpler Cipher｜Gao&#39;s Blog"
    />
    <meta
      property="og:description"
      content="Cracking Simpler Cipher｜Gao&#39;s Blog"
    />
    <meta name="author" content="Gao" />
    <meta name="robots" content="index, follow" />
    <meta
      property="og:image"
      content="https://vitaminac.github.io/images/favicon.jpg"
    />
    <link rel="shortcut icon" href="/images/favicon.jpg" />

    <meta
      name="keywords"
      content="Caesar Cipher,Cifrado César,Código de César,Vigenère cipher,Cifrado de Vigenère,Transposition Cipher,Cifrado por transposición"
    />

    <meta name="theme-color" content="#600090" />
    <meta name="msapplication-navbutton-color" content="#600090" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090" />
    <link
      rel="alternate"
      type="application/atom+xml"
      title="Gao&#39;s Blog"
      href="/atom.xml"
    />

    <link
      rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css"
      cross-origin="anonymous"
      referrer-policy="no-referrer"
    />
    <link
      rel="canonical"
      href="https://vitaminac.github.io/Cracking-Simpler-Cipher/"
    />

    <!-- jQuery -->
    <script
      type="text/javascript"
      src="https://code.jquery.com/jquery-3.6.0.min.js"
    ></script>
    <!-- Bootstrap -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
      integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"
      integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js"
      integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF"
      crossorigin="anonymous"
    ></script>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css" />
    <link rel="stylesheet" href="/css/syntax.css" />

    <!-- Google Tag Manager -->

    <script>
      (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({ "gtm.start": new Date().getTime(), event: "gtm.js" });
        var f = d.getElementsByTagName(s)[0],
          j = d.createElement(s),
          dl = l != "dataLayer" ? "&l=" + l : "";
        j.async = true;
        j.src = "https://www.googletagmanager.com/gtm.js?id=" + i + dl;
        f.parentNode.insertBefore(j, f);
      })(window, document, "script", "dataLayer", "GTM-WDC9JKC");
    </script>

    <!-- End Google Tag Manager -->

    <!-- Global site tag (gtag.js) - Google Analytics -->

    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=UA-151409235-1"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "UA-151409235-1");
    </script>

    <!-- Google AdSense -->
    <script
      data-ad-client="ca-pub-8356359077918854"
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"
    ></script>
    <meta name="generator" content="Hexo 6.3.0" />
  </head>
  <style>
    header.intro-header {
      background-image: url("/images/header.gif");
    }
  </style>
  <!-- hack iOS CSS :active style -->

  <body ontouchstart="" class="animated fadeIn">
    <!-- Main Content -->

    <!--only post-->

    <img
      class="wechat-title-img"
      src="/_next/static/media/default-post-preview.c96b099a.jpeg"
    />

    <!-- Post Content -->
    <article class="container" style="width: 100%; max-width: 100%">
      <!-- Post Container -->
      <div class="post-container">
        <h1 id="Cifrado-por-sustitucion-monoalfabetica-Cifrado-Cesar">
          <a
            href="#Cifrado-por-sustitucion-monoalfabetica-Cifrado-Cesar"
            class="headerlink"
            title="Cifrado por sustitución monoalfabética (Cifrado César)"
          ></a
          >Cifrado por sustitución monoalfabética (Cifrado César)
        </h1>
        <p>
          El cifrado César, también conocido como cifrado por desplazamiento es
          un cifrado por sustitución monoalfabética.
        </p>
        <p>La codificación de cifrado Cesar tiene la siguiente forma</p>
        <p>$$<br />E_n(x) &#x3D; x + n \mod 27<br />$$</p>
        <p>La decodificación se hace de manera similar</p>
        <p>$$<br />D_n(x) &#x3D; x - n \mod 27<br />$$</p>
        <h1 id="Procedimiento-de-descifracion">
          <a
            href="#Procedimiento-de-descifracion"
            class="headerlink"
            title="Procedimiento de descifración"
          ></a
          >Procedimiento de descifración
        </h1>
        <p>
          Supongamos que tenemos siguiente texto cifrado por el cifrado César
          con un desplazamiento desconocido
        </p>
        <pre><code>OV M1SZ3YKXKVS2S2 O2 VK ZK13O NO VK M1SZ3YVYQSK 04O 2O NONSMK KV O234NSY NO 2S23OWK2 M1SZ3YQ1KPSMY2 MYX OV PSX NO OXMYX31K1 NOLSVSNKNO2 OX VY2 2S23OWK2 8 1YWZO1 24 2OQ41SNKN 2SX OV MYXYMSWSOX3Y NO SXPY1WKMSYX 2OM1O3K  OX OV VOXQ4KTO XY 3OMXSMY  2O MYXYMO O23K Z1KM3SMK MYWY 1YWZO1 Y PY19K1 OV MYNSQY  K4X04O O23K O7Z1O2SYX 3SOXO 4X 2SQXSPSMKNY O2ZOMSPSMY NOX31Y NOV K1QY3 3OMXSMY  K VK2 ZO12YXK2 04O 2O NONSMKX KV M1SZ3YKXKVS2S2 2O VO2 VVKWK M1SZ3YKXKVS23K2
</code></pre>
        <p>
          Si el texto no es aleatorio, con el análisis de frecuencia podemos
          encontrar la clave $n$ sin mucha dificultad. Sabemos que normalmente
          en un texto español los vocales aparecen más frecuente.
        </p>
        <p>
          Hemos creado una función que analiza la frecuencia de aparición de
          cada letra dada, y observa cual era las letras que tenía una mayor
          frecuencia de aparición y las distancias entre ellas obtuvimos la “A”.
        </p>
        <p>
          Con lo cual, sacamos el número -10 para descifrar y 10 para cifrar, en
          este caso, a la hora de descifrar, es lo mismo poner -10 que 26.
        </p>
        <pre><code>def count(content):
    for c in &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;:
        print(c, &quot; appears &quot;, content.count(c))
</code></pre>
        <p>El resultado es siguiente</p>
        <pre><code>A  appears  0
B  appears  0
C  appears  0
D  appears  0
E  appears  0
F  appears  0
G  appears  0
H  appears  0
I  appears  0
J  appears  0
K  appears  37
L  appears  1
M  appears  27
N  appears  18
O  appears  51
P  appears  6
Q  appears  7
R  appears  0
S  appears  37
T  appears  1
U  appears  0
V  appears  21
W  appears  8
X  appears  27
Y  appears  35
Z  appears  12
0  appears  3
1  appears  23
2  appears  34
3  appears  21
4  appears  9
5  appears  0
6  appears  0
7  appears  1
8  appears  1
9  appears  1
</code></pre>
        <p>
          Notamos que K, O, S, Y apareces muchas veces y las distancias entre
          ellos es 4, 4, 6 que justo son las distancias entre a, e, i, o,
          deducimos que la <strong>K</strong> es <strong>a</strong> y el
          desplazamiento es <strong>10</strong>
        </p>
        <pre><code>def encrypt(content, n):
    alphabets = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;
    return &quot;&quot;.join([alphabets[(alphabets.index(c) + n + len(alphabets)) % len(alphabets)] if c in alphabets else c for c in content])
</code></pre>
        <p>
          Para descifrar el algoritmo que se emplea es el mismo que el del
          cifrado y <strong>n</strong> tenemos que usar <strong>-10</strong>.
        </p>
        <p>El contenido del archivo descifrado es</p>
        <pre><code>EL CRIPTOANALISIS ES LA PARTE DE LA CRIPTOLOGIA QUE SE DEDICA AL ESTUDIO DE SISTEMAS CRIPTOGRAFICOS CON EL FIN DE ENCONTRAR DEBILIDADES EN LOS SISTEMAS Y ROMPER SU SEGURIDAD SIN EL CONOCIMIENTO DE INFORMACION SECRETA  EN EL LENGUAJE NO TECNICO  SE CONOCE ESTA PRACTICA COMO ROMPER O FORZAR EL CODIGO  AUNQUE ESTA EXPRESION TIENE UN SIGNIFICADO ESPECIFICO DENTRO DEL ARGOT TECNICO  A LAS PERSONAS QUE SE DEDICAN AL CRIPTOANALISIS SE LES LLAMA CRIPTOANALISTAS
</code></pre>
        <h1 id="Cifrado-por-sustitucion-simple-polialfabetico-Cifrado-Vigenere">
          <a
            href="#Cifrado-por-sustitucion-simple-polialfabetico-Cifrado-Vigenere"
            class="headerlink"
            title="Cifrado por sustitución simple polialfabético (Cifrado Vigenère)"
          ></a
          >Cifrado por sustitución simple polialfabético (Cifrado Vigenère)
        </h1>
        <p>
          El cifrado <strong>Vigenère</strong> es un cifrado de
          <strong>sustitución simple poli alfabético</strong>. Su funcionamiento
          es siguiente<br />$$<br />E(X_i) &#x3D; (X_i + K_i) \mod L<br />$$<br />donde
          $X_i$ es la letra en la posición $i$ del texto a cifrar, $K_{i}$ es el
          carácter de la clave correspondiente a $X_i$, pues se encuentran en la
          misma posición, y $L$ es el tamaño del alfabeto.
        </p>
        <p>
          Para descifrar realizamos la operación inversa:<br />$$<br />D(C_i)
          &#x3D; (C_i - K_i) \mod L<br />$$<br />Donde $C_{i}$ es el carácter en
          la posición i del texto cifrado, $K_{i}$ viene siendo el carácter de
          la clave correspondiente a $C_{i}$, y $L$ el tamaño del alfabeto.
        </p>
        <h1 id="Descifrar">
          <a href="#Descifrar" class="headerlink" title="Descifrar"></a
          >Descifrar
        </h1>
        <p>
          Para el texto cifrado más corto que la clave es imposible crackearlo,
          y si la clave no es aleatoria y el texto es sufiencientemente largo
          entonces se puede obtener información sobre la clave utilizada.
        </p>
        <p>Ahora tenemos un texto cifrado que queremos descifrar</p>
        <pre><code>GW CCMR4OVRCWIDMU PS 6E RLREI FP LV GTTPESNZG3E S5E DI FPD3GC LL ZWV5D3S FP S3WVPMVW E2IAXQRRVJKNOD GQY E6 JKY DZ IPNO8XTLR YIDTL3HCOED IP WOD WK3TZQC3 Y CSO0EC WW 3E1YTTDVH UTN ZP EZN9GKXIZRVZ DZ MPQOCQCNI9R UPCCIVL  E8 IN WE8KWLJZ RQ 4EXRKNO  DI EZN9GG PSEE R2AXXKNA XSOZ R9QRPR 9 JQ2ZVV GW C9HKRO  VYP1UZ IU4A Z1R2EDMQY T3IPP U8 WKRN3JKNAYS G3PZGKQIXS FPNEVQ OE6 ETROE XGNN3GQ  L LVW RPRDSPLS BYG 3E YIFTCVR CW CCMR4OVRCWIDMU 3E 6IU WLVQC NR3TVZA8ENTSEEU
</code></pre>
        <h2 id="Adivinar-la-longitud-de-la-clave">
          <a
            href="#Adivinar-la-longitud-de-la-clave"
            class="headerlink"
            title="Adivinar la longitud de la clave"
          ></a
          >Adivinar la longitud de la clave
        </h2>
        <p>
          Lo primero que vamos a hacer es buscar las repeticiones de las
          secuencias, para ello, hemos implementado este script.
        </p>
        <pre><code>from collections import OrderedDict
def cal_distance(content):
    alphabets = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;
    sequences = content.split()
    for s in list(OrderedDict.fromkeys(sequences)):
        count = sequences.count(s)
        if count &gt; 1:
            index = sequences.index(s)
            lastIndex = len(sequences) - sequences[::-1].index(s) - 1
            distance = 0
            for i in range(index, lastIndex):
                distance += len(sequences[i])
            print(s, index, lastIndex, distance)
</code></pre>
        <p>Y el resultado que obtenemos es</p>
        <table>
          <thead>
            <tr>
              <th>secuencia</th>
              <th align="center">distancia</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>GW</td>
              <td align="center">240</td>
            </tr>
            <tr>
              <td>CCMR4OVRCWIDMU</td>
              <td align="center">340</td>
            </tr>
            <tr>
              <td>FP</td>
              <td align="center">35</td>
            </tr>
            <tr>
              <td>DI</td>
              <td align="center">160</td>
            </tr>
            <tr>
              <td>DZ</td>
              <td align="center">70</td>
            </tr>
            <tr>
              <td>3E</td>
              <td align="center">25</td>
            </tr>
          </tbody>
        </table>
        <p>
          Siguiendo el proceso de encriptación de
          <strong>Vigenère</strong> sabemos que cada letra de clave se vuelve a
          aplicar otra vez cuando han pasado <strong>L</strong> caracteres.
          Deducimos desde aquí́ que la longitud de la clave debe ser como
          <strong>máximo el común divisor</strong> de las distancias que hemos
          encontrado. A ojo creemos que la clave tiene la longitud
          <strong>5</strong>.
        </p>
        <h2 id="Dividir-la-entrada-en-longitud-de-cinco">
          <a
            href="#Dividir-la-entrada-en-longitud-de-cinco"
            class="headerlink"
            title="Dividir la entrada en longitud de cinco"
          ></a
          >Dividir la entrada en longitud de cinco
        </h2>
        <p>
          Cuando ya sabemos la longitud de la clave, dividimos la entrada en
          bloque de cinco caracteres también, la misma posición de cada bloque
          se cifra contra la misma posición de la clave. Y vemos si existe algún
          patrón
        </p>
        <pre><code>def divive_bloque(string):
    strings = &quot;&quot;.join(string.split())
    blocks = [strings[i:i+5] for i in range(0, len(strings), 5)]
    for block in blocks:
        print(block)
</code></pre>
        <p>El resultado que tenemos siguiente</p>
        <pre><code>GWCCM
R4OVR
CWIDM
UPS6E
RLREI
FPLVG
TTPES
NZG3E
S5EDI
FPD3G
CLLZW
V5D3S
FPS3W
VPMVW
E2IAX
QRRVJ
KNODG
QYE6J
KYDZI
PNO8X
TLRYI
DTL3H
COEDI
PWODW
K3TZQ
C3YCS
O0ECW
W3E1Y
TTDVH
UTNZP
EZN9G
KXIZR
VZDZM
PQOCQ
CNI9R
UPCCI
VLE8I
NWE8K
WLJZR
Q4EXR
KNODI
EZN9G
GPSEE
R2AXX
KNAXS
OZR9Q
RPR9J
Q2ZVV
GWC9H
KROVY
P1UZI
U4AZ1
R2EDM
QYT3I
PPU8W
KRN3J
KNAYS
G3PZG
KQIXS
FPNEV
QOE6E
TROEX
GNN3G
QLLVW
RPRDS
PLSBY
G3EYI
FTCVR
CWCCM
R4OVR
CWIDM
U3E6I
UWLVQ
CNR3T
VZA8E
NTSEE
U
</code></pre>
        <h2 id="Analisis-sobre-cada-grupo">
          <a
            href="#Analisis-sobre-cada-grupo"
            class="headerlink"
            title="Análisis sobre cada grupo"
          ></a
          >Análisis sobre cada grupo
        </h2>
        <p>
          Para cada posición de la clave formamos cada grupo de entrada y nos
          encontraría con el problema de cifrado Cesar que podemos hacer el
          análisis de frecuencia como hemos comentado en su apartado. Agrupamos
          la salida del resultado anterior con el siguiente script
        </p>
        <pre><code>def group(content):
    lines = content.split(&quot;\n&quot;)
    groups = [&quot;&quot;] * 5
    for line in lines:
        for i in range(len(line)):
            groups[i] += line[i]
    for g in groups:
        print(g)
</code></pre>
        <p>Obtenemos siguientes cincos tiras de cadenas</p>
        <pre><code>GRCURFTNSFCVFVEQKQKPTDCPKCOWTUEKVPCUVNWQKEGRKORQGKPURQPKKGKFQTGQRPGFCRCUUCVNU
W4WPLPTZ5PL5PP2RNYYNLTOW3303TTZXZQNPLWL4NZP2NZP2WR142YPRN3QPORNLPL3TW4W3WNZT
COISRLPGEDLDSMIROEDORLEOTYEEDNNIDOICEEJEONSAARRZCOUAETUNAPINEONLRSECCOIELRAS
CVD6EVE3D3Z33VAVD6Z8Y3DDZCC1VZ9ZZC9C88ZXD9EXX99V9VZZD383YZXE6E3VDBYVCVD6V38E
MRMEIGSEIGWSWWXJGJIXIHIWQSWYHPGRMQRIIKRRIGEXSQJVHYI1MIWJSGSVEXGWSYIRMRMIQTEE
</code></pre>
        <p>
          Usamos la función que usamos para contar la frecuencia en cifrado
          Cesar para cada cadena
        </p>
        <pre><code>A  appears  0
B  appears  0
C  appears  8
D  appears  1
E  appears  3
F  appears  5
G  appears  6
H  appears  0
I  appears  0
J  appears  0
K  appears  10
L  appears  0
M  appears  0
N  appears  3
O  appears  2
P  appears  6
Q  appears  7
R  appears  7
S  appears  1
T  appears  4
U  appears  7
V  appears  5
W  appears  2
X  appears  0
Y  appears  0
Z  appears  0
0  appears  0
1  appears  0
2  appears  0
3  appears  0
4  appears  0
5  appears  0
6  appears  0
7  appears  0
8  appears  0
9  appears  0
</code></pre>
        <p>El primer caracter de la clave parece que es <strong>C</strong>.</p>
        <p>
          Repetimos las prueba y finalmente hemos encontrado que la clave es
          <strong>CLAVE</strong>.
        </p>
        <pre><code>def frecuency_per_group(text, x):
    alphabets = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;
    text = &quot;&quot;.join([b if b in alphabets else &quot;&quot; for b in text])
    groups = []
    for i in range(x):
        groups.append(&quot;&quot;)
    for i in range(len(text)):
        groups[i % 5] += text[i]
    for i in range(x):
        print(&quot;columna &quot;, i)
        count(groups[i])
</code></pre>
        <h1 id="Cifrado-por-transposicion">
          <a
            href="#Cifrado-por-transposicion"
            class="headerlink"
            title="Cifrado por transposición"
          ></a
          >Cifrado por transposición
        </h1>
        <p>
          Un cifrado por transposición es un tipo de cifrado en el que unidades
          de texto plano se cambian de posición siguiendo un esquema bien
          definido. Es decir, hay una permutación de
          <strong>unidades de texto</strong>.
        </p>
        <p>
          En una transposición columnar, el mensaje se escribe en filas de una
          longitud fija, la longitud de clave, y luego se lee columna por
          columna, y las columnas se eligen por el orden alfabético de las
          letras en la palabra clave.
        </p>
        <p>
          Por ejemplos con la clave <strong>432143</strong> ciframos
          <strong>WE ARE DISCOVERED. FLEE AT ONCE</strong> y un padding al final
        </p>
        <pre><code>6 3 2 4 1 5
W E A R E D
I S C O V E
R E D F L E
E A T O N C
E ? ? ? ? ?
</code></pre>
        <p>El resultado es</p>
        <pre><code>EVLN? ACDT? ESEA? ROFO? DEEC? WIREE
</code></pre>
        <h1 id="Desencriptacion">
          <a
            href="#Desencriptacion"
            class="headerlink"
            title="Desencriptación"
          ></a
          >Desencriptación
        </h1>
        <p>Supongamos que tenemos siguiente texto cifrado</p>
        <pre><code>IA    O ECEOISTIOF TEANSAOSU LCTIASAEGNNSOTCCOOAC,UAETUNDEOR  CLR EC OS LRNA LTISAEROUD TDTCGO NNAIELS P IICM FIC  A C E IMPF DA EIE F ID RE.SOUDNRNSEMPL.CAILTLPI DLD MIA LDO I SE REA NEERNENEEE,OERA RRLGNSPNEICSINEONAPA DAPLS  OS EPLEPDCLQ AS S OCNIERBD ISMURS IONCE.LUOIECATOM RO E SINIOC OATOASQ ACAILAIASRNSAEATASI ISAPFC ENDDE MR GDEON M T N C NSA R Z OQTR  GAPCTLTI ESSILTIELCAT  OS R IGEEAUEERRSE CRLSOTYESDNOIDOORELJTOC PCOEOEIUEXONSIEFEDGC  NEE IA SATID
</code></pre>
        <p>
          Primero de todo tenemos que fijar la longitud de la clave, con la
          esquema anterior sabemos que la longitud de la debe ser tiene un
          divisor de la longitud del texto cifrado. La longitud de nuestro texto
          cifrado es 462 y sus divisores son 1, 2, 3, 6, 7, 11, 14, 21, 22, 33,
          42, 66, 77, 154, 231, 462.
        </p>
        <p>
          Probamos diferentes longitudes que sea divisor de la longitud del
          texto usando siguiente función Python
        </p>
        <pre><code>def split(text, x):
    alphabets = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;
    s = &quot;&quot;
    n = int(len(text) / x)
    for i in range(n):
        for j in range(x):
            if text[i + j * n] in alphabets:
                s += text[i + j * n]
            else:
                s += &quot;-&quot;
            s += &quot; &quot;
        s += &quot;\n&quot;
    return s
</code></pre>
        <p>Observamos que en el caso de la longitud 6</p>
        <pre><code>I L C E R -
A T A P N O
- I I L S S
- S L E A -
- A T P E R
- E L D A -
O R P C T I
- O I L A G
E U - Q S E
C D D - I E
E - L A - A
O T D S I U
I D - - S E
S T M S A E
T C I - P R
I G A O F R
O O - C C S
F - L N - E
- N D I E -
T N O E N C
E A - R D R
A I I B D L
N E - D E S
S L S - - O
A S E I M T
O - - S R Y
S P R M - E
U - E U G S
- I A R D D
L I - S E N
C C N - O O
T M E I N I
I - E O - D
A F R N M O
S I N C - O
A C E E T R
E - N - - E
G - E L N L
N A E U - J
N - E O C T
S C - I - O
O - O E N C
T E E C S -
C - R A A P
C I A T - C
O M - O R O
O P R M - E
A F R - Z O
C - L R - E
- D G O O I
U A N - Q U
A - S E T E
E E P - R X
T I N S - O
U E E I - N
N - I N G S
D F C I A I
E - S O P E
O I I C C F
R D N - T E
- - E O L D
- R O A T G
C E N T I C
L - A O - -
R S P A E -
- O A S S N
E U - Q S E
C D D - I E
- N A A L -
O R P C T I
S N L A I A
- S S I E -
L E - L L S
R M - A C A
N P O I A T
A L S A T I
- - - S - D
</code></pre>
        <p>
          Observamos el resultado obtenido y ordenamos a ojo y obtenemos el
          orden de aparición es Columna 4, Columna 2, Columna 6, Columna 1,
          Columna 5, Columna 3, su clave númerica es 426351 y la clave
          alfabético es <strong>DBFCEA</strong>, la cual se obtiene por orden de
          columnas tomando como referencia la posición de letra en su alfabeto.
        </p>
        <h1 id="Cifrado-por-sustitucion-monoalfabetica-y-transposicion">
          <a
            href="#Cifrado-por-sustitucion-monoalfabetica-y-transposicion"
            class="headerlink"
            title="Cifrado por sustitución monoalfabética y transposición"
          ></a
          >Cifrado por sustitución monoalfabética y transposición
        </h1>
        <p>
          Si nos tocamos hacer una desencriptación combinada de cifrado por
          César y transposition que haríamos. Si tenemos siguiente texto
          cifrado:
        </p>
        <pre><code> TX W NLJJFZJJWWXJ HWQXTY3JXISTNITTWJQOYTH UHTJTJNZJ2TSXNJKJILH  SJJ NF XFYNDJUQJUIHQV FX X THSNJWGI NXRZWX NTSHJ QZTNJHFYTR WT J XNSNTH TFYTFXV FHFNQFNFXNF    T JHJTNXYNTK YJFSXFTXZ QHYNFXFJLSSXTYHHTTFH ZFJYZSIJTW  HQW JH TX QWSF WSXFJFYFXN NXFUKH JSIIJ RW LIJTS R Y S H SXF W 4 TVYW  LFUHYQYN JXXNQYNJQHFY HFNQYQUN IQI RNF QIT N XJ WJF SJJWSJSJJJ TJWF WWQLSXUSJNHXNSJTSFUF IFUQX  TX QYNXFJWTZI YIYHLT SSFNJQX U NNHR KNH  F H J NRUK IF JNJ K NI WJ XTZISWSXJRUQ
</code></pre>
        <h1 id="Texto-cifrado">
          <a href="#Texto-cifrado" class="headerlink" title="Texto cifrado"></a
          >Texto cifrado
        </h1>
        <p>
          Primero desencriptamos la parte de sustitución monoalfabética, usamos
          la estrategia que hemos empleado en el cifrado César, contamos la
          frecuencia de aparición de cada letra.
        </p>
        <pre><code>A  appears  0
B  appears  0
C  appears  0
D  appears  1
E  appears  0
F  appears  37
G  appears  1
H  appears  27
I  appears  18
J  appears  51
K  appears  6
L  appears  7
M  appears  0
N  appears  37
O  appears  1
P  appears  0
Q  appears  21
R  appears  8
S  appears  27
T  appears  35
U  appears  12
V  appears  3
W  appears  23
X  appears  34
Y  appears  21
Z  appears  9
0  appears  0
1  appears  0
2  appears  1
3  appears  1
4  appears  1
5  appears  0
6  appears  0
7  appears  0
8  appears  0
9  appears  0
</code></pre>
        <p>
          Observamos que la clave de encriptación de sustitución es muy probable
          que sea 5.
        </p>
        <p>
          Desencriptamos primero el cifrado monoalfabética usando la llave y la
          función que usemos en cifrado de César. Ahora tenemos siguiente texto:
        </p>
        <pre><code>OS R IGEEAUEERRSE CRLSOTYESDNOIDOORELJTOC PCOEOEIUEXONSIEFEDGC  NEE IA SATI8EPLEPDCLQ AS S OCNIERBD ISMURS IONCE LUOIECATOM RO E SINIOC OATOASQ ACAILAIASIA    O ECEOISTIOF TEANSAOSU LCTIASAEGNNSOTCCOOAC UAETUNDEOR  CLR EC OS LRNA\x00RNSAEATASI ISAPFC ENDDE MR GDEON M T N C NSA R Z OQTR  GAPCTLTI ESSILTIELCAT\x00CAILTLPI DLD MIA LDO I SE REA NEERNENEEE OERA RRLGNSPNEICSINEONAPA DAPLS  OS\x00LTISAEROUD TDTCGO NNAIELS P IICM FIC  A C E IMPF DA EIE F ID RE SOUDNRNSEMPL
</code></pre>
        <p>
          Seguimos con los pasos que hemos explicado en cifrado por
          transposición, hallamos primero la longitud de la clave a partir de la
          longitud de texto cifrado que es <strong>462</strong>, y sus divisores
          son 1, 2, 3, 6, 7, 11, 14, 21, 22, 33, 42, 66, 77, 154, 231, 462.
          Probamos esas posibilidades y encontramos que con la longitud 6,
          obtenemos siguiente resultado
        </p>
        <pre><code>- E I R C L
O P A N A T
S L - S I I
- E - A L S
R P - E T A
- D - A L E
I C O T P R
G L - A I O
E Q E S - U
E - C I D D
A A E - L -
U S O I D T
E - I S - D
E S S A M T
R - T P I C
R O I F A G
S C O C - O
E N F - L -
- I - E D N
C E T N O N
R R E D - A
L B A D I I
S D N E - E
O - S - S L
T I A M E S
Y S O R - -
E M S - R P
S U U G E -
D R - D A I
N S L E - I
O - C O N C
I I T N E M
D O I - E -
O N A M R F
O C S - N I
R E A T E C
E - E - N -
L L G N E -
J U N - E A
T O N C E -
O I S - - C
C E O N O -
- C T S E E
P A C A R -
C T C - A I
O O O R - M
E M O - R P
O - A Z R F
E R C - L -
I O - O G D
U - U Q N A
E E A T S -
X - E R P E
O S T - N I
N I U - E E
S N N G I -
I I D A C F
E O E P S -
F C O C I I
E - R T N D
D O - L E -
G A - T O R
C T C I N E
- O L - A -
- A R E P S
N S - S A O
E Q E S - U
E - C I D D
- A - L A N
I C O T P R
A A S I L N
- I - E S S
S L L L - E
A A R C - M
T I N A O P
I A A T S L
8 S - - - -
</code></pre>
        <p>
          Observamos que el orden de columnas es: 316542 y por lo tanto, la
          clave de la transposición es BFAEDC por la misma razón que explicamos
          que cifrado por transposición, ahora sobre el texto desencriptado
          aplicamos esta transposición y obtenemos texto original.
        </p>
        <h1 id="Cifrado-de-Vigenere-mas-transposicion">
          <a
            href="#Cifrado-de-Vigenere-mas-transposicion"
            class="headerlink"
            title="Cifrado de Vigenère más transposición"
          ></a
          >Cifrado de Vigenère más transposición
        </h1>
        <p>
          Primero buscamos la longitud de la clave, la longitud de texto cifrado
          es 460, y sus divisores son 1, 2, 4, 5, 10, 20, 23, 46, 92, 115, 230,
          460. Y con la longitud de la clave 5 obtenemos las siguientes columnas
        </p>
        <pre><code>P J T R -
1 T U A 1
V Y F S T
M T X 5 -
- - L U L
P I 4 - T
Y I M A -
Q - N 2 W
W T Z T Q
V I L 2 -
P R - - S
I I M N Q
Y F - - I
2 E 3 Q Y
I I Z M -
3 - 5 Y I
3 M Z - A
P H Z 4 V
A T O Q 4
S N K - 1
- N T R V
N L - V Q
- - Q P E
N S K 4 1
- W I D 4
Y P G I Q
R O F S L
- - P T S
3 1 S N -
X 0 6 F E
- 0 - R B
R Z R R X
- - 3 0 Z
W R G Q 5
- Q A X O
E Q 0 W -
0 - H O W
V N N E U
- Y Y Q W
S E - N T
F 1 R K X
- V O X Y
P M P Y R
R I - N -
- - P T Q
Z R N I R
Y W E T -
C - 1 Y R
- N K - 1
H S P W -
J 0 O - N
L M 5 - T
C U Z 4 N
- N K C N
- Z R 4 W
M O X 4 U
Q - O T -
2 Z C - A
P J T O -
1 O N - O
S - A Y 5
P 7 E X -
E 1 N 8 -
S U Z T R
6 T V I -
- P S 7 M
N N - O 3
N 0 I K Q
- N D J Z
N 0 2 N E
Z N V - C
T I M 2 0
R T - L L
O - L 1 W
J T - K 4
T 0 I - N
Y - I A -
M 3 - 4 U
I S Z 5 S
J - Q - 5
D 0 R P -
A I Q Y P
- - F P T
1 R T 1 U
T A Y V F
- S T 0 X
P R - X L
A - T X Y
4 F - I K
N 0 Y N W
5 L Q T Q
B L X - -
</code></pre>
        <p>
          Y con la aparición de los espacios podemos deducir el orden,
          reordenamos las columnas
        </p>
        <p>J T - P R<br />T U 1 1 A<br />Y F T V S<br />T X - M 5</p>
        <ul>
          <li>L L - U<br />I 4 T P -<br />I M - Y A</li>
          <li>
            N W Q 2<br />T Z Q W T<br />I L - V 2<br />R - S P -<br />I M Q I
            N<br />F - I Y -<br />E 3 Y 2 Q<br />I Z - I M
          </li>
          <li>
            5 I 3 Y<br />M Z A 3 -<br />H Z V P 4<br />T O 4 A Q<br />N K 1 S
            -<br />N T V - R<br />L - Q N V
          </li>
          <li>
            Q E - P<br />S K 1 N 4<br />W I 4 - D<br />P G Q Y I<br />O F L R S
          </li>
          <li>
            P S - T<br />1 S - 3 N<br />0 6 E X F<br />0 - B - R<br />Z R X R R
          </li>
          <li>3 Z - 0<br />R G 5 W Q<br />Q A O - X<br />Q 0 - E W</li>
          <li>
            H W 0 O<br />N N U V E<br />Y Y W - Q<br />E - T S N<br />1 R X F
            K<br />V O Y - X<br />M P R P Y<br />I - R N -<br />P Q - T R<br />N
            R Z I W<br />E - Y T -<br />1 R C Y N<br />K 1 - S P
          </li>
          <li>
            H W 0 O<br />N J - M 5<br />T L - U Z<br />N C 4 N K<br />N - C Z
            R<br />W - 4 O X<br />U M 4 - O
          </li>
          <li>Q T Z C<br />A 2 - J T</li>
          <li>
            P O O N<br />O 1 - A 5<br />S Y 7 E -<br />P X 1 N -<br />E 8 U Z
            R<br />S T T V -<br />6 I P S M
          </li>
          <li>7 N - 3<br />N O 0 I Q<br />N K N D Z</li>
          <li>
            J 0 2 E<br />N N N V C<br />Z - I M 0<br />T 2 T - L<br />R L - L
            W<br />O 1 T - 4<br />J K 0 I N<br />T - I - Y<br />A 3 - U M<br />4
            S Z S I<br />5 - Q 5 J
          </li>
          <li>
            0 R - D<br />P I Q P A<br />Y - F T -<br />P R T U 1<br />1 A Y F
            T<br />V S T X -<br />0 R - L P<br />X - T Y A<br />X F - K 4<br />I
            0 Y W N<br />N L Q Q 5<br />T L X - -
          </li>
        </ul>
        <p>
          Agrupamos en 5 grupos que debemos tener en cuenta las letras que no
          están en el alfabeto no cifra por Vigenère, usamos función que hemos
          comentado en cifrado por Vigenère frecuency_per_group y analizando las
          frecuencias de vocales hemos obtenido que la clave.
        </p>

        <hr />

        <ul class="list-group"></ul>
      </div>
    </article>
    <!-- Custom Theme JavaScript -->
    <script type="text/javascript" src="/js/blog.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js"></script>
    <script>
      $(document).ready(function () {
        anchors.add("p");
      });
    </script>

    <!-- mathjax -->
    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
          jax: ["input/TeX", "output/SVG"],
          extensions: ["tex2jax.js"],
          showMathMenu: false,
          SVG: { useGlobalCache: false },
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
              processEscapes: true
          },
          TeX: {
              equationNumbers: { autoNumber: "AMS" },
              noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
              Macros: { href: "{}" }
          }
      });
    </script>
    <script
      type="text/javascript"
      async
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML-full"
    ></script>

    <!-- jquery.tagcloud.js -->
    <script>
      // only load tagcloud.js in tag.html
      if ($("#tag_cloud").length !== 0) {
        async("https://vitaminac.github.io/js/jquery.tagcloud.js", function () {
          $.fn.tagcloud.defaults = {
            //size: {start: 1, end: 1, unit: 'em'},
            color: {
              start: "#bbbbee",
              end: "#0085a1",
            },
          };
          $("#tag_cloud a").tagcloud();
        });
      }
    </script>

    <script type="text/javascript" src="/js/common.js"></script>

    <script type="text/javascript">
      $("code").addClass("language-python");
    </script>
    <script type="text/javascript" src="/js/prism.js"></script>
    <script type="text/javascript">
      addCSS("//css/prism.css");
      Prism.highlightAll();
    </script>

    <!-- render ipynb file -->

    <!-- render ipynb file -->
  </body>
</html>
